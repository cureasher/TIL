# 1장 깨끗한 코드
## (1) 코드가 존재하리라
- 코드란 요구사항을 상세히 표현하는 수단
## (2) 나쁜코드
- 이전 버전에 있었던 버그가 다음 버전에 남는 코드
- 나중에 고치겠다는 코드
- 르블랑의 법칙
    > 나중은 결코 오지 않는다
## (3) 나쁜 코드로 치르는 대가
### 1) 원대한 재설계의 꿈
- 기존 시스템
    > 엉망이고 생산성 바닥인 시스템
- 새 시스템 설계
    > 기존 시스템의 기능을 모두 제공
- 깨끗한 코드를 만드는 노력이 비용을 절감하는 방법
### 2) 태도
- 좋은 코드를 사수하는 일 
    > `프로그래머의 책임`
### 3) 원초적 난제
- 언제나 코드를 최대한 깨끗하게 유지하는 습관
### 4) 깨끗한 코드라는 예술
- 코드 감각이 있는 프로그래머는 나쁜 모듈을 알아봄
    > 좋은 모듈로 `개선할 방안`을 떠올림
### 5) 깨끗한 코드란? 
- 언제나 코드를 최대한 깨끗하게 유지하는 습관을 갖자!
1. 비야네 스트롭스트룹
    - 논리가 간단해야 버그가 숨어들지 못함
    - 의존성을 최대한 줄여야 유지보수가 쉬워짐
    - 오류는 `명백한 전략`에 의거해 철저히 처리
    - 세세한 사항까지 `꼼꼼하게 처리`하는 코드
    - `한가지에 집중한 코드`
    - C++ 창시자
2. 그래디 부치
    - 단순하고 직접적인 코드
    - 코드는 추측이 아니라 `사실`에 기반
    - 가독성을 강조
    - 결코 설계자의 의도를 숨기지 않음
    - 명쾌한 추상화와 단순한 제어문으로 구성
3. 데이브 토마스
    - 작성자가 아닌 사람도 `읽기 쉽고 고치기도 쉬움`
    - 특정 목적을 달성하는 방법은 하나만 제공
    - 의존성
        > 최소, 명확히 정의
4. 마이클 페더스
    - 고치려고 살펴봐도 딱히 손 댈 곳이 없는 코드
    - 주의 깊게 짠 코드
5. 론 제프리스
    - 켄트 벡이 제안한 단순한 코드 규칙
        - 모든 테스트 통과
        - 중복이 없음
        - 시스템 내 모든 설계 아이디어 표현
        - 클래스, 메서드, 함수 최대한 줄임
    - 중복을 피하라
    - 한 기능만 수행하라
    - 제대로 표현하라
    - 작게 추상화
6. 워드 커닝햄
    - 읽으면서 놀랄일이 없어야 함
    - 짐작대로 돌아가는 코드
### 4) 우리들 생각
- 깨끗한 변수 이름, 함수, 클래스
### 5) 우리는 저자다
- 주변 코드가 읽기 쉬우면 새코드 짜기 쉽다
- 읽기 쉽게 만들자
### 6) 보이스카우트 규칙
- 캠프장은 처음 왔을때 보다 더 깨끗하게 해놓고 떠나라
- 시간이 지날수록 코드가 좋아지는 프로젝트 작업
    - 변수 이름 개선
    - 긴 함수 분할
    - 약간의 중복 제거
    - 복잡한 if문 정리
### 7) 프리퀼과 원칙
- 객체지향 설계의 원칙을 설명
- 전문 개발자들이 사용하는 실무기법
### 8) 결론
- 뛰어난 프로그래머가 생각하는 방식
- 그들이 사용하는 기술을 소개

# 2장 의미 있는 이름
## (1) 들어가면서
- 변수, 함수, 인수, 클래스, 패키지에도 이름이 있다
## (2) 의도를 분명히 밝혀라
- `의도`가 분명하게 이름을 짓자
- 변수, 함수, 클래스 이름
    - 존재 이유
    - 수행 기능
    - 사용 방법
    - `주석이 필요 없어도 이해가 되야함`
## (3) 그릇된 정보를 피하라
- 서로 흡사한 이름을 사용하지 않도록 주의
- 일관성이 떨어지는 표기법
- 주의할 변수명
    - 소문자 L은 숫자 1처럼 보일 수 있음
    - 대문자 O는 숫자 0처럼 보일 수 있음
    - 글꼴을 바꿔 차이를 드러내면 해결됨
## (4) 의미 있게 구분하라
- 정보를 제공하지 않는 이름 사용하지 말자
- 연속된 숫자를 덧붙이는 것은 적절하지 않음
- 의미가 불분명한 불용어
    - info, data, a, an, the
- 중복되는 단어 사용 금지
    - 변수이름 variable
    - 표이름 table
- 읽는 사람이 차이를 알도록 이름을 짓자
## (5) 발음하기 쉬운 이름을 사용하라
- 사람들은 단어에 능숙
- 발음하기 어려운 변수명
    - genymdhms
    - 질문하기도 어려움
- 발음하기 쉬운 변수명
    - generationTimestamp
    - 단어를 사용하면 질문하기 쉬움
## (6) 검색하기 쉬운 이름을 사용하라
- 문자 하나를 사용하는 이름과 상수는 피해라
    - 문자 하나 사용하는 변수
        - 문자 하나가 들어가는 파일이름, 수식이 모두 검색 됨
        - 찾으려는 파일 찾기 힘듬
    - 긴 이름이 짧은 이름보다 좋다
## (7) 인코딩을 피하라
- 유형이나 범위정보까지 넣지 말자
- 인코딩이 많을수록 그만큼 해독이 어려움
- 인코딩한 이름
    - 발음이 어려움
    - 오타가 생길 수 있음
### 1) 헝가리식 표기법
- 옛날 프로그래밍 언어
    - 이름 길이가 제한 됨
    - 컴파일러가 타입을 점검 안 함
- 요즘 프로그래밍 언어
    - 훨씬 많은 타입을 지원 
    - 컴파일러가 타입을 기억하고 강제함
    - 변수에 타입을 인코딩할 필요없음
### 2) 멤버 변수 접두어
- 클래스와 함수
    - 멤버변수에 접두어 붙일 필요 없음
- IDE 사용 추천
    - 멤버 변수를 다른 색상으로 표시하거나 눈에 띄게 보여줌
- 사람들이 읽을 때 접두어를 무시하고 이름을 읽음
### 3) 인터페이스 클래스와 구현 클래스
- 인터페이스 이름은 접두어를 붙이지 않는 편이 좋음
- 다루는 클래스가 인터페이스임을 알리고 싶지 않음
    - IShapeFactory 추천 안 함
- 인터페이스보단 구현 클래스를 인코딩하는게 나음
    - ShapeFactoryImp, CShapeFactory 추천
## (8) 자신의 기억력을 자랑하지 마라
- 변수 이름을 자신이 아는 이름으로 변환하면 바람직하지 않음
    - 문제 영역이나 해법 영역에서 사용하지 않는 이름을 썼기 때문
- 문자 하나만 사용하는 변수 이름
    - i, j, k는 괜찮음
        > 가급적 쓰지 말고 index에 맞춰서 변수명 줘야 함
    - l은 절대 안됨
    - 루프에서 반복횟수 변수는 전통적으로 한 글자 사용
- 전문가 프로그래머는 `남들이 이해하는 코드`를 내놓음
## (9) 클래스 이름
- `명사`나 `명사구`가 적합
- 좋은예
    - Customer, WikiPage, Account, AddressParser
- 피해야할 단어
    - Manager, Proceser, Data, Info
- `동사`는 사용하지 않음
## (10) 메서드 이름
- `동사`나 `동사구`가 적합
- 좋은예
    - postPayment, deletePage, save
- 접근자, 변경자, 조건자
    - javabean 표준 따름
    - 값 앞에 get, set, is를 붙임
- 생성자를 중복정의(overload)할때 정적 팩토리 메서드 사용
```java
    // 추천
    Complex fulcrumPoint = Complex.FromRealNumber(23.0);
    // 비추천
    Complex fulcrumPoint = new Complex(23.0);
```
## (11) 기발한 이름은 피하라
- 재미난 이름보다 `명료한 이름`을 선택
- 특정문화에서만 사용하는 농담은 피해라
- 의도를 분명하고 솔직하게 표현
## (12) 한 개념에 한 단어를 사용하라
- 추상적인 개념 하나에 단어 하나를 선택
- 메서드 이름
    > `독자적`, `일관적`
- 혼란스러운 코드
    1. fetch, retrieve, get
    2. controller, manager, driver
- 이름이 다르면 독자는 클래스와 타입이 다르다 생각함
    > 가져오다는 표현 사용시 `한가지 단어로 통일`해서 사용
- 일관성 있는 `어휘` 사용
## (13) 말장난을 하지 마라
- 한 단어를 두가지 목적으로 사용하지 마라
    - 모든 매개변수와 반환값이 같아야 함
- 같은 맥락이 아닌 경우 다른 이름 사용
- add
    - 두 값을 더하거나 새로운 값 만들때 사용
- append, insert
    - 집합에 값을 추가할 경우 사용
- 대충 훑어봐도 이해할 수 있는 코드 작성
## (14) 해법 영역에서 가져온 이름을 사용하라
- 코드를 읽을 사람은 프로그래머
- 전산용어, 알고리즘 이름, 패턴 이름, 수학용어 사용
- 모든 이름을 도메인(문제영역)에서 가져오는 정책은 현명하지 않음
- 기술개념에는 기술 이름이 적합
## (15) 문제 영역에서 가져온 이름을 사용하라
- 적절한 프로그래밍 용어가 없을시 문제영역에서 가져옴
- 우수한 프로그래머와 설계자
    > 해법 영역과 문제 영역을 구분할 줄 알아야 함
## (16) 의미 있는 맥락을 추가하라
- 스스로 의미가 분명한 이름 사용
- 접두어를 사용해 `맥락`을 더 `분명`하게 만들 수 있음 
- `클래스`를 사용하면 더 좋음
## (17) 불필요한 맥락을 없애라
- 일반적으로 짧은 이름이 긴 이름보다 좋음(의미가 분명한 경우)
- Address 메서드보다 클래스에 적합
- 포트 주소, MAC 주소, 웹주소
    > PostalAddress, MAC, URI
- 의미를 분명하게 사용
## (18) 마치면서
- 읽히는 코드
    - 문장이나 문단처럼
    - 표나 자료구조처럼
- 코드를 개선하려는 노력을 중단해선 안됨

# 3장 함수
## (1) 작게 만들어라!
- 첫째 규칙 `작게`
- 둘째 규칙 `더 작게`
### 1) 블록과 들여쓰기
- if문, else문, while문 들어가는 블록은 한줄이어야 함
    - `함수`를 호출 함
- 중첩구조가 생길만큼 함수가 커져서는 안 됨
- 함수 들여쓰기 수준은 `1단`, `2단`이 적당
## (2) 한 가지만 해라!
- 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행
- 의미 있는 이름으로 다른 함수 추출
### 1) 함수 내 섹션
- 한가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어려움
## (3) 함수 당 추상화 수준은 하나로!
- 함수 내 모든 문장의 추상화 수준이 동일
- 추상화 수준이 섞이면 코드를 읽는 사람이 헷갈림
### 1) 위에서 아래로 코드 읽기: 내려가기 규칙
- 위에서 아래로 이야기처럼 읽혀야 함
## (4) Switch 문
- 작게 만들기 어려움
- 본질적으로 N가지 처리
- 다형성을 이용해 저차원 클래스에 숨기고 절대로 반복하지 않음
- 단일책임원칙 위반
    - 코드를 변경할 이유가 여러가지
- 개방폐쇄원칙 위반
    - 새 직원 유형을 추가할 때마다 코드를 변경해야함
    - switch문을 추상팩토리에 숨김
    - switch문에서 파생 클래스의 인스턴스를 생성
- 상속 관계를 숨긴후 절대로 다른 코드에 노출하지 않음
## (5) 서술적인 이름을 사용하라!
- 좋은이름은 함수가 하는 일을 좀더 잘 표현
- 모듈 내에서 함수이름은 같은문구, 명사, 동사를 사용
- 좋은예
    - includeSetupAndTeardownPages
    - includeSuiteSetupPage
    - includeSetupPages
    - includeSetupPage
## (6) 함수 인수
- 함수에서 이상적인 인수 개수는 0개(무항)
- 그 다음은 1개(단항)과 2개(이항)
- 3개(삼항)은 피하는 편이 좋음
- 테스트 관점 복잡해짐
    - 갖가지 인수 조합으로 함수 검증 필요
### 1) 많이 쓰는 단항 형식
1. 인수에 질문을 던지는 경우
    ```java
        boolean fileExists("MyFile")
    ```
2. 인수를 뭔가로 변환해 결과를 반환하는 경우
    ```java
        InputStream fileOpen("MyFile")
    ```
### 2) 플래그 인수
- 함수의 인자로 부울값을 넘기는 관례는 피해라
- 함수가 여러가지 처리한다고 공표하는 것과 같기 때문
- renderForSuite()과 renderForSingleTest()함수로 나누는게 좋음
### 3) 이항 함수
- 이항함수는 단항함수보다 이해하기 어려움
- assertEquals(expected, actual)
    - expected 인수에 actual 값을 집어넣으면 안됨
    - 인수의 순서를 기억애햐 함
- 단항함수로 바꾸도록 애써야 함
- 직교 좌표계 점은 일반적으로 인수 2개를 취함
### 4) 삼항 함수
- 이항함수보다 훨씬 어려움
- 신중히 고려할 것 권고
### 5) 인수 객체
- 인수가 2~3개 필요한 경우 일부를 클래스 변수로 선언 가능한지 살펴야 함
### 6) 인수 목록
- 인수 개수가 가변적인 함수도 필요
- 가변인수를 취하는 함수는 단항, 이항, 삼항 함수로 취급
- 삼항함수를 넘어서는 인수사용 문제
### 7) 동사와 키워드
- 좋은 함수 이름은 `함수의 의도`, `인수의 순서와 의도`를 제대로 표현
- 단항 함수
    - 함수와 인수(`동사/명사`)쌍을 이룸
    - write(name)
- `함수 이름에 키워드 사용`
    - assertExpectedEqualsActual(expected, actual)
    - 함수 이름에 인수를 넣어 인수 순서를 기억하지 않아도 됨
## (7) 부수 효과를 일으키지 마라!
- 부수효과
    - 함수에서 한가지를 하겠다고 약속하고 남몰래 다른일을 하는 것
    - 함수 이름과 상관없는 일은 지양
    - 시간적인 결합, 순서종속성 초래할 수 있음
- checkPasswordAndInitializeSession
    - 함수가 한가지만 한다는 규칙 위반함
        - 패스워드 확인과 세션 초기화를 같이 함
    - 시간적인 결합이 필요한 경우 명시하는 것이 좋음
### 1) 출력 인수
- 일반적으로
    - 인수를 `함수 입력`으로 해석
    - 출력인수는 피해야 함
- 객체지향 언어에서는 출력 인수를 사용할 필요가 거의 없음
- 출력인수로 사용하라고 설계한 변수
    - `this`
- 함수 상태 변경
    - 함수가 속한 `객체 상태`를 변경
## (8) 명령과 조회를 분리하라!
- 함수는 수행하거나 답하거나 둘 중 하나만 해야 함
- 객체 상태 변경, 객체 정보 반환
- 설정하는 코드인지 확인하는 코드인지 분간이 안감
    ```java
        if(set("username", "unclebob"))
    ```
- 명령과 조회를 분리해서 코드 작성
    ```java
        if(attributeExits("username")){
            setAttribute("username", "unclebob");
        }
    ```
## (9) 오류 코드보다 예외를 사용하라!
- 명령 함수에서 오류코드 반환하는 방식
    - 명령/조회 분리 규칙 미묘하게 위반
- 오류코드 대신 예외 사용
    - 오류처리코드가 원래 코드에서 분리되므로 코드가 깔끔해짐
### 1) Try/Catch 블록 뽑아내기
- 정상 동작과 오류 처리 동작을 뒤섞음
- try/catch 블록은 별도 함수로 뽑아내는 편이 좋음
### 2) 오류 처리도 한 가지 작업이다.
- 함수는 `한가지` 작업만 해야 함
- 오류처리도 한가지 작업임
- 오류만 처리해야함
### 3) Error.java 의존성 자석
- 오류코드 반환
    - 클래스나 열거형 변수나 어디선가 오류 코드를 정의하는 것
    - Error enum을 사용하는 클래스 전부를 다시 컴파일하고 재배치 해야 함
        - 번거롭기에 새 오류 코드 정의하는 것 추천하지 않음
- 기존 `오류코드 재사용`을 추천
- 예외 사용시 새 예외는 Exception 클래스에서 `파생`됨
    - `재컴파일, 재배치 없이` 새 예외클래스 추가할 수 있음
## (10) 반복하지 마라!
- 중복을 없애면 `모듈 가독성`이 높아짐
- 많은 원칙과 기법이 `중복을 제어`할 목적으로 나옴
- 관계형 데이터베이스 정규 형식
    - 중복제거 목적
- 객체지향 프로그래밍
    - 코드를 부모 클래스로 몰아 중복을 없앰
## (11) 구조적 프로그래밍
1. 구조적 프로그래밍 원칙
    - 모든 함수와 함수 내 모든 블록에 `입구와 출구가 하나만 존재`
    - 함수는 `return문이 하나여야 함`
    - 루프 안
        - break, continue, goto 사용 안할 것을 추천
    - 함수가 클 경우 이익 제공
    - 구조적 프로그래밍은 함수가 적으면 별 이익 없음
2. 함수가 작은 경우
    - return, break, continue 여러차례 사용해도 괜찮음
        - `단일 입/출구 규칙`보다 의도를 표현하기 쉬워짐
    - goto문은 큰 함수에서만 의미가 있음
        - 작은 함수에선 피해야 함
## (12) 함수를 어떻게 짜죠?
- 처음엔 길고 복잡함
- 코드를 다듬고 함수 만들고 이름 바꾸며 중복을 제거함
- 메서드 줄이고 순서를 바꿈
- 전체 클래스를 쪼개기도 함
- 코드를 빠짐없이 테스트하는 단위테스트를 만들고 통과함
## (13) 결론
- 대가 프로그래머
    - 시스템을 `구현할` 프로그램이 아니라 `풀어갈` 이야기로 여김
- 진짜 목표
    - 시스템이라는 이야기를 풀어가는 것
- 함수는 분명하고 정확한 언어로 깔끔하게 맞아 떨어져야 함
- 길이가 짧고, 이름이 좋고, 체계가 잡힌 함수 작성

# 4장 주석
- 우리는 코드로 `의도를 표현하지 못해` 주석을 사용
- 코드로 의도를 표현
- `코드를 깔끔하게 정리, 표현력을 강화`
- 부정확한 주석은 아예 없는 주석보다 훨씬 더 나쁨
- 우리는 주석을 가능한 줄이도록 꾸준히 노력
## (1) 주석은 나쁜 코드를 보완하지 못한다
- 코드에 주석 추가하는 일반적인 이유
    - 코드품질이 나쁘기 때문
- 표현력이 풍부하고 깔끔하며 주석이 없는 코드 best
- 복잡하고 어수선하며 주석이 많이 달린 코드 worst
## (2) 코드로 의도를 표현하라!
- 코드만으로 의도를 설명하기 어려운 경우도 존재함
- 주석으로 달려는 설명을 함수로 만들어도 충분
```java
    // 좋은예
	if (employee.isEligibleForFullBenefits())
```
```java
    // 나쁜예
    // 직원에게 복지 혜택을 받을 자격이 있는지 검사한다.
    if ((employee.flags & HOURLY_FLAG) && (employee.age > 65))
```
## (3) 좋은 주석
- 필요하거나 유익한 주석도 있음
- 주석을 달지 않을 방법을 찾아낸 주석
### 1) 법적인 주석
- 소스 파일 첫 머리에 들어가는 주석
    - 저자권 정보, 소유권 정보 등 법적 정보
### 2) 정보를 제공하는 주석
```java
    // 테스트 중인 Responder 인스턴스를 반환한다.
	protected abstract Responder responderInstance();
```
- 함수 이름을 responderBeingTested를 쓰면 주석이 필요 없음
- 함수 이름에 정보를 담는 편이 더 좋음
- 정규 표현식 설명하는 주석
    - 시각과 날짜를 변환하는 클래스를 만들어 코드를 옮겨주면 더 깔끔
### 3) 의도를 설명하는 주석
- 구현을 이해하게 도와주는 설명
```java
    return 1; // 정렬 순위가 더 높다
    // 스레드를 대량 생성하는 방법으로 어떻게든 경쟁 조건을 만들려 시도한다.
```
### 4) 의미를 명료하게 밝히는 주석
- 의미를 읽기 좋게 표현
    - 이해하기 쉬워짐
- 인수나 반환값이 표준 라이브러리나 변경하지 못할 경우
    - 의미를 명료하게 밝히는 주석 유용
- 주석이 올바른지 검증이 쉽지 않음
    - 위험한 주석이 될 수 있음
```java
    assertTrue(a.compareTo(a) == 0); // a == a
```
### 5) 결과를 경고하는 주석
 - 실행할 때 주의 필요한 케이스
    - 실행이 오래 걸리는 경우
    - 테스트 케이스를 꺼줘야 함
    - `@Ignore` 속성을 이용해 테스트 케이스를 끌 수 있다
### 6) TODO 주석
- TODO를 많이 쓰는 것은 바람직하지 않음
- 당장 구현하기 어려운 업무
- 필요 없는 기능 삭제하라는 알림
- 누군가에게 문제를 봐달라는 요청
- 앞으로 발생할 이벤트에 맞춰 코드 수정하란 주의
### 7) 중요성을 강조하는 주석
- 자칫 대수롭지 않게 중요성을 강조할 수 있음
```java
    // trim 함수는 문자열에서 시작 공백을 제거한다.
    // 문자열에 시작 공백이 있으면 다른 문자열로 인식되기 때문이다.
```
### 8) 공개 API에서 Javadocs
- 설명이 잘된 공개 API 유용
    - 표준 자바 라이브러리에 사용한 Javadocs
## (4) 나쁜 주석
- 대다수의 주석
- 허술한 코드
### 1) 주절거리는 주석
- 이해가 안되어 다른 모듈까지 뒤져야 하는 주석
    - 독자와 제대로 소통하지 못함
### 2) 같은 이야기를 중복하는 주석
- 주석이 같은 코드 내용을 그대로 중복한 경우
    - 자칫하면 코드보다 주석 읽는 시간이 더 걸림
- 코드만 지저분하고 정신없게 만듬
    - 함수를 대충 이해하고 넘어갈 수 있음
### 3) 오해할 여지가 있는 주석
- 프로그래머가 딱 맞을 정도로 엄밀하게 주석을 달지 못함
- 코드를 오해하면 이유를 찾는데 골머리 앓게 됨 
### 4) 의무적으로 다는 주석
- 코드를 복잡하게 만듦
- 혼동가 무질서를 초래함
### 5) 이력을 기록하는 주석
- 모듈의 변경 이력을 기록
- 소스 코드 관리 시스템이 없었을땐 필요했음
- 현재는 혼란만 일으키므로 완전히 제거하는 편이 좋음
### 6) 있으나 마나 한 주석
- 너무 당연한 사실을 언급
- 새로운 정보를 제공하지 못하는 주석
- 주석을 다는 것보다 코드를 정리하는 것이 나음
### 7) 무서운 잡음
- 문서를 제공해야 한다는 잘못된 욕심으로 탄생
### 8) 함수나 변수로 표현할 수 있다면 주석을 달지 마라
- 함수나 변수로 표현할 수 있다면 주석을 달지마라
- 주석이 필요하지 않도록 개선하는 편이 좋음
### 9) 위치를 표시하는 주석
- 소스파일에서 특정위치를 표시하려는 주석
- 가독성만 낮추므로 제거해야 마땅함
### 10) 닫는 괄호에 다는 주석
- 중첩이 심한경우 의미가 있을수 있음
- 작고 캡슐화된 함수에는 잡음
- 함수를 줄이길 추천
### 11) 공로를 돌리거나 저자를 표시하는 주석
- 저자를 표시하는 주석은 소스 코드 관리 시스템에 저장하는 편이 좋음
### 12) 주석으로 처리한 코드
- 다른 사람들이 지우길 주저하게 됨
- 이유가 있어 남겼으리라 생각함
### 13) HTML 주석
- 편집에, IDE에서도 읽기 어려움
### 14) 전역 정보
- 주석을 달려면 근처에 있는 코드만 기술
- 시스템 전반적인 정보 기술하지마라
### 15) 너무 많은 정보
- 흥미로운 역사나 관련 없는 정보 장황하게 적지마라
### 16) 모호한 관계
- 주석과 주석이 설명한 코드는 둘 사이 관계가 명백 해야함
### 17) 함수 헤더
- 짧은 함수는 긴 설명이 필요없음
- 짧고 한가지만 수행하며 이름을 잘 붙인 함수가 훨씬 좋음
### 18) 비공개 코드에서 Javadocs
- 공개하지 않을 코드는 Javadocs은 쓸모가 없음

# 5장 형식 맞추기
- 형식을 깔끔하게 맞춰 코드 작성
- 팀이 합의해 규칙을 정하고 따름
- 필요시 규칙을 자동으로 적용하는 도구 활용
## (1) 형식을 맞추는 목적
- 코드 형식은 의사소통의 일환
- 구현한 기능은 다음 버전에서 바뀔 확률이 아주 높음
- 원래 코드는 사라져도 개발자의 스타일과 규율은 사라\지지 않음
## (2) 적절한 행 길이를 유지하라
- 큰 파일보다 작은 파일이 이해하기 쉬움
- 200줄 정도인 파일로도 커다란 시스템 구축할 수 있음
### 1) 신문 기사처럼 작성하라
- 이름은 간단하면서 설명 가능하게 작성
- 소스 파일 첫부분 고차원 개념과 알고리즘 설명
- 내려 갈수록 의도를 세세하게 묘사
- 마지막에 저차원 함수와 세부내역 작성
### 2) 개념은 빈 행으로 분리하라
- 일련의 행 묶음
    - 완결된 생각 하나를 표현
- 빈행
    - 새로운 개념을 시작한다는 시각적 단서
### 3) 세로 밀집도
- 연관성을 의미
- 밀접한 코드 행은 세로로 가까이 놓음
### 4) 수직 거리
- 서로 밀접한 개념은 세로에 가까이 작성
- 밀접한 관계는 한 파일에 속해야 함
1. 변수선언
    - 변수
        - 사용하는 위치에 최대한 가까이 선언
    - 지역변수
        - 각 함수 맨 처음에 선언
    - 루프 제어 변수
        - 루프 문 내부에 선언
2. 인스턴스 변수
    - 클래스 맨 처음에 선언
    - 잘 설계한 클래스
        - 많은 클래스 메서드가 인스턴스 변수 사용
3. 종속함수
    - 함수가 다른 함수 호출
        - 세로로 가까이 배치
        - 호출하는 함수를 호출되는 함수보다 먼저 배치
        - 프로그램이 자연스럽게 읽힘
        - 모듈 전체 가독성 상승
4. 개념적 유사성
    - 직접적인 종속성
        - 한 함수가 다른 함수호출해 생김
    - 친화도 높은 요인
        - 변수와 변수를 사용하는 함수
        - 비슷한 동작을 수행하는 함수
        - 명명법이 똑같고 기본 기능이 유사한 코드 
### 5) 세로 순서
- 함수호출 종속성 아래 방향 유지
- 소스코드 모듈이 고차원에서 저차원으로 내려감
- 가장 중요한 개념을 가장 먼저 표현
- 세세한 사항
    - 최대한 배제
    - 가장 마지막에 표현
## (3) 가로 형식 맞추기
- 120자 정도로 행길이 제한
### 1) 가로 공백과 밀집도
- 가로 공백
    - 밀접한 개념과 느슨한 개념 표현
- 할당문
    - 왼쪽 요소와 오른쪽 요소가 분명히 나뉨
- 함수 이름과 이어지는 괄호 사이 공백 안씀
    - 함수와 인수는 서로 밀접하기때문
- 연산자 우선순위 강조 공백 사용
### 2) 가로 정렬
- 특정 구조를 강조하고자할 때 사용
    - 지금은 사용하지 않음
    - 코드 형식을 자동으로 맞춰주는 도구가 정렬을 무시함
### 3) 들여쓰기
- 범위로 이뤄진 계층을 표현하기 위해 사용
- 클래스 내 메서드는 클래스보다 한수준 들여씀
- 메서드 코드는 메서드 선언보다 한수준 둘여씀
- 들여쓰기 한 파일은 구조가 한눈에 들어옴
## (4) 가짜 범위
- 빈 블록은 올바로 들여쓰고 괄호로 감쌈
- 세미콜론은 새행에 제대로 들여써서 넣어줌
## (5) 팀 규칙
- 한 가지 규칙에 합의
- 규칙을 따라야 소프트웨어가 일관적인 스타일을 보임
- 괄호위치, 들여쓰기 몇 자, 클래스, 변수, 메서드이름

# 6장 객체와 자료 구조
- 변수를 비공개로 정의하는 이유
    - 남들이 변수에 의존하지 않게 만들기 위함
## (1) 자료 추상화
- 변수 사이에 함수를 넣는다고 구현이 감춰지지 않음
- 구현을 감추려면 추상화 필요
- 추상 인터페이스
    - 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 함
- 자료를 세세하게 공개하기보다 추상적인 개념으로 표현
## (2) 자료/객체 비대칭
- 객체는 추상화 뒤로 자료를 숨긴채 자료를 다루는 함수만 공개
- 자료구조는 자료를 공개하며 별다른 함수 제공 안함
- 절차적인 코드
    - 기존 자료 구조를 변경하지 않으면서 새 함수 추가하기 쉬움
- 객체지향 코드
    - 기존 함수를 변경하지 않으면서 새 클래스 추가하기 쉬움
## (3) 디미터 법칙
- 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙
- 객체는 조회함수로 내부 구조를 공개하면 안됨
### 1) 기차 충돌
- 자료구조는 무조건 함수 없이 공개 변수만 포함
- 객체는 비공개 변수와 공개 함수를 포함
### 2) 잡종 구조
- 절반은 객체, 절반은 자료구조인 구조
- 중요한 기능을 수행하는 함수
- 공개변수나 공개 조회 설정 함수
### 3) 구조체 감추기
- 객체에 뭔가를 하라고 말해야 함
- 속을 드러내라고 하면 안됨
- 모듈에서 해당 함수
    - 자신이 몰라야 하는 여러 객체를 탐색할 필요 없음
## (4) 자료 전달 객체
- Data Transfer Object(DTO)
- 자료 구조체
    - 공개 변수만 있고 함수가 없는 클래스
    - 데이터베이스와 통신하거나 소켓에서 받은메시지 구문 분석할 때 유용
### 1) 활성 레코드
- DTO의 특수한 형태
- 자료구조 취급
- 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성
## (5) 결론
- 객체
    - 동작을 공개하고 자료를 숨김
    - 기존 동작을 변경하지 않으면서 새 객체 타입 추가 쉬움
    - 기존 객체에 새 동작 추가하기 어려움
- 자료구조
    - 별다른 동작 없이 자료 노출
    - 새 동작 추가하기 쉬우나 기존함수에 새 자료구조 추가 어려움

# 7장 오류 처리
- 프로그램 논리를 이해하기 어려워지면 깨끗한 코드라 부르기 어려움
- 프로그램에 반드시 필요한 요소 중 하나
    - 입력이 이상하거나 디바이스가 실패할지 모르기 때문
## (1) 오류 코드보다 예외를 사용하라
- 함수 호출한 즉시 오류를 확인해야 됨
    - 확이해야할 단계를 잊어버기 쉬움
- 오류 발생시 예외를 던지는 편이 나음
    - 호출 코드 깔끔함
- 디바이스 종료 알고리즘과 오류 처리 알고리즘 분리
## (2) Try-Catch-Finally 문부터 작성하라
- 강제로 예외를 일으키는 테스트 케이스 작성
    - 테스트를 통과하게 코드 작성 권장
- try 블록
    - 어느 시점에서든 실행이 중단된 후 catch 블록으로 넘어감
- catch 블록
    - 프로그램 상태 일관성 있게 유지
- 예외가 발생할 코드 작성시 try-catch-finally문으로 시작 추천
## (3) 미확인unchecked 예외를 사용하라
- 확인된 예외는 OCP를 위반함
- 하위 단계에서 코드를 변경하면 상위 단계 메서드 선언부를 전부 고쳐야 함
## (4) 예외에 의미를 제공하라
- 예외를 던질 때 전후 상황을 충분히 설명
    - 오류가 발생한 원인과 위치를 찾기 쉬움
## (5) 호출자를 고려해 예외 클래스를 정의하라
- 오류를 분류하는 방법
	- 오류 발생 위치
	- 오류 발생 컴포넌트
	- 오류 유형
		- 디바이스 실패
		- 네트워크 실패
		- 프로그래밍 오류
- 오류 정의할때 가장 중요한 관심사
	- 오류를 잡아내는 방법이 되어야 함
- 오류 처리하는 방식
    - 오류 기록
    - 프로그램을 계속 수행해도 좋은지 확인
- 외부 API를 감싸면 외부 라이브러리와 프로그램 사이의 의존성이 줄어듬
## (6) 정상 흐름을 정의하라
- 외부 API를 감싸 독자적인 예외 던짐
- 코드 위에 처리기를 정의해 중단된 계산 처리
- 때로는 중단이 적합하지 않을때도 있음
- 특수 사례 패턴
    - 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식
    - 클라이언트 코드가 예외적인 상황을 처리할 필요가 없어짐
        - 클래스나 객체가 예외적인 상황을 캡슐화해서 처리함
## (7) null을 반환하지 마라
- null을 반환하는 코드는 일거리를 늘림
- 호출자에게 문제를 떠넘김
    - null 확인을 빼먹을 경우 통제 불능될 수 있음
- 리스트 null 반환 해결법
    - 빈리스트 반환
## (8) null을 전달하지 마라
- 메서드에서 null 반환하는 방식 나쁨
	- 메서드로 null을 전달하는 방식은 더 나쁨
- null이 정상적인 인수인 경우를 제외하고는 최대한 피해야 함
- assert문 사용
## (9) 결론
- 깨끗한 코드는 읽기도 좋아야 하지만 안전성도 높아야 함
- 오류 처리는 프로그램 논리와 분리하면 독립적 추론 가능

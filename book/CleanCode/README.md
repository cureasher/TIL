# 1장 깨끗한 코드
## (1) 코드가 존재하리라
- 코드란 요구사항을 상세히 표현하는 수단
## (2) 나쁜코드
- 이전 버전에 있었던 버그가 다음 버전에 남는 코드
- 나중에 고치겠다는 코드
- 르블랑의 법칙
    > 나중은 결코 오지 않는다
## (3) 나쁜 코드로 치르는 대가
### 1) 원대한 재설계의 꿈
- 기존 시스템
    > 엉망이고 생산성 바닥인 시스템
- 새 시스템 설계
    > 기존 시스템의 기능을 모두 제공
- 깨끗한 코드를 만드는 노력이 비용을 절감하는 방법
### 2) 태도
- 좋은 코드를 사수하는 일 
    > `프로그래머의 책임`
### 3) 원초적 난제
- 언제나 코드를 최대한 깨끗하게 유지하는 습관
### 4) 깨끗한 코드라는 예술
- 코드 감각이 있는 프로그래머는 나쁜 모듈을 알아봄
    > 좋은 모듈로 `개선할 방안`을 떠올림
### 5) 깨끗한 코드란? 
- 언제나 코드를 최대한 깨끗하게 유지하는 습관을 갖자!
1. 비야네 스트롭스트룹
    - 논리가 간단해야 버그가 숨어들지 못함
    - 의존성을 최대한 줄여야 유지보수가 쉬워짐
    - 오류는 `명백한 전략`에 의거해 철저히 처리
    - 세세한 사항까지 `꼼꼼하게 처리`하는 코드
    - `한가지에 집중한 코드`
    - C++ 창시자
2. 그래디 부치
    - 단순하고 직접적인 코드
    - 코드는 추측이 아니라 `사실`에 기반
    - 가독성을 강조
    - 결코 설계자의 의도를 숨기지 않음
    - 명쾌한 추상화와 단순한 제어문으로 구성
3. 데이브 토마스
    - 작성자가 아닌 사람도 `읽기 쉽고 고치기도 쉬움`
    - 특정 목적을 달성하는 방법은 하나만 제공
    - 의존성
        > 최소, 명확히 정의
4. 마이클 페더스
    - 고치려고 살펴봐도 딱히 손 댈 곳이 없는 코드
    - 주의 깊게 짠 코드
5. 론 제프리스
    - 켄트 벡이 제안한 단순한 코드 규칙
        - 모든 테스트 통과
        - 중복이 없음
        - 시스템 내 모든 설계 아이디어 표현
        - 클래스, 메서드, 함수 최대한 줄임
    - 중복을 피하라
    - 한 기능만 수행하라
    - 제대로 표현하라
    - 작게 추상화
6. 워드 커닝햄
    - 읽으면서 놀랄일이 없어야 함
    - 짐작대로 돌아가는 코드
### 4) 우리들 생각
- 깨끗한 변수 이름, 함수, 클래스
### 5) 우리는 저자다
- 주변 코드가 읽기 쉬우면 새코드 짜기 쉽다
- 읽기 쉽게 만들자
### 6) 보이스카우트 규칙
- 캠프장은 처음 왔을때 보다 더 깨끗하게 해놓고 떠나라
- 시간이 지날수록 코드가 좋아지는 프로젝트 작업
    - 변수 이름 개선
    - 긴 함수 분할
    - 약간의 중복 제거
    - 복잡한 if문 정리
### 7) 프리퀼과 원칙
- 객체지향 설계의 원칙을 설명
- 전문 개발자들이 사용하는 실무기법
### 8) 결론
- 뛰어난 프로그래머가 생각하는 방식
- 그들이 사용하는 기술을 소개

# 2장 의미 있는 이름
## (1) 들어가면서
- 변수, 함수, 인수, 클래스, 패키지에도 이름이 있다
## (2) 의도를 분명히 밝혀라
- `의도`가 분명하게 이름을 짓자
- 변수, 함수, 클래스 이름
    - 존재 이유
    - 수행 기능
    - 사용 방법
    - `주석이 필요 없어도 이해가 되야함`
## (3) 그릇된 정보를 피하라
- 서로 흡사한 이름을 사용하지 않도록 주의
- 일관성이 떨어지는 표기법
- 주의할 변수명
    - 소문자 L은 숫자 1처럼 보일 수 있음
    - 대문자 O는 숫자 0처럼 보일 수 있음
    - 글꼴을 바꿔 차이를 드러내면 해결됨
## (4) 의미 있게 구분하라
- 정보를 제공하지 않는 이름 사용하지 말자
- 연속된 숫자를 덧붙이는 것은 적절하지 않음
- 의미가 불분명한 불용어
    - info, data, a, an, the
- 중복되는 단어 사용 금지
    - 변수이름 variable
    - 표이름 table
- 읽는 사람이 차이를 알도록 이름을 짓자
## (5) 발음하기 쉬운 이름을 사용하라
- 사람들은 단어에 능숙
- 발음하기 어려운 변수명
    - genymdhms
    - 질문하기도 어려움
- 발음하기 쉬운 변수명
    - generationTimestamp
    - 단어를 사용하면 질문하기 쉬움
## (6) 검색하기 쉬운 이름을 사용하라
- 문자 하나를 사용하는 이름과 상수는 피해라
    - 문자 하나 사용하는 변수
        - 문자 하나가 들어가는 파일이름, 수식이 모두 검색 됨
        - 찾으려는 파일 찾기 힘듬
    - 긴 이름이 짧은 이름보다 좋다
## (7) 인코딩을 피하라
- 유형이나 범위정보까지 넣지 말자
- 인코딩이 많을수록 그만큼 해독이 어려움
- 인코딩한 이름
    - 발음이 어려움
    - 오타가 생길 수 있음
### 1) 헝가리식 표기법
- 옛날 프로그래밍 언어
    - 이름 길이가 제한 됨
    - 컴파일러가 타입을 점검 안 함
- 요즘 프로그래밍 언어
    - 훨씬 많은 타입을 지원 
    - 컴파일러가 타입을 기억하고 강제함
    - 변수에 타입을 인코딩할 필요없음
### 2) 멤버 변수 접두어
- 클래스와 함수
    - 멤버변수에 접두어 붙일 필요 없음
- IDE 사용 추천
    - 멤버 변수를 다른 색상으로 표시하거나 눈에 띄게 보여줌
- 사람들이 읽을 때 접두어를 무시하고 이름을 읽음
### 3) 인터페이스 클래스와 구현 클래스
- 인터페이스 이름은 접두어를 붙이지 않는 편이 좋음
- 다루는 클래스가 인터페이스임을 알리고 싶지 않음
    - IShapeFactory 추천 안 함
- 인터페이스보단 구현 클래스를 인코딩하는게 나음
    - ShapeFactoryImp, CShapeFactory 추천
## (8) 자신의 기억력을 자랑하지 마라
- 변수 이름을 자신이 아는 이름으로 변환하면 바람직하지 않음
    - 문제 영역이나 해법 영역에서 사용하지 않는 이름을 썼기 때문
- 문자 하나만 사용하는 변수 이름
    - i, j, k는 괜찮음
        > 가급적 쓰지 말고 index에 맞춰서 변수명 줘야 함
    - l은 절대 안됨
    - 루프에서 반복횟수 변수는 전통적으로 한 글자 사용
- 전문가 프로그래머는 `남들이 이해하는 코드`를 내놓음
## (9) 클래스 이름
- `명사`나 `명사구`가 적합
- 좋은예
    - Customer, WikiPage, Account, AddressParser
- 피해야할 단어
    - Manager, Proceser, Data, Info
- `동사`는 사용하지 않음
## (10) 메서드 이름
- `동사`나 `동사구`가 적합
- 좋은예
    - postPayment, deletePage, save
- 접근자, 변경자, 조건자
    - javabean 표준 따름
    - 값 앞에 get, set, is를 붙임
- 생성자를 중복정의(overload)할때 정적 팩토리 메서드 사용
```java
    // 추천
    Complex fulcrumPoint = Complex.FromRealNumber(23.0);
    // 비추천
    Complex fulcrumPoint = new Complex(23.0);
```
## (11) 기발한 이름은 피하라
- 재미난 이름보다 `명료한 이름`을 선택
- 특정문화에서만 사용하는 농담은 피해라
- 의도를 분명하고 솔직하게 표현
## (12) 한 개념에 한 단어를 사용하라
- 추상적인 개념 하나에 단어 하나를 선택
- 메서드 이름
    > `독자적`, `일관적`
- 혼란스러운 코드
    1. fetch, retrieve, get
    2. controller, manager, driver
- 이름이 다르면 독자는 클래스와 타입이 다르다 생각함
    > 가져오다는 표현 사용시 `한가지 단어로 통일`해서 사용
- 일관성 있는 `어휘` 사용
## (13) 말장난을 하지 마라
- 한 단어를 두가지 목적으로 사용하지 마라
    - 모든 매개변수와 반환값이 같아야 함
- 같은 맥락이 아닌 경우 다른 이름 사용
- add
    - 두 값을 더하거나 새로운 값 만들때 사용
- append, insert
    - 집합에 값을 추가할 경우 사용
- 대충 훑어봐도 이해할 수 있는 코드 작성
## (14) 해법 영역에서 가져온 이름을 사용하라
- 코드를 읽을 사람은 프로그래머
- 전산용어, 알고리즘 이름, 패턴 이름, 수학용어 사용
- 모든 이름을 도메인(문제영역)에서 가져오는 정책은 현명하지 않음
- 기술개념에는 기술 이름이 적합
## (15) 문제 영역에서 가져온 이름을 사용하라
- 적절한 프로그래밍 용어가 없을시 문제영역에서 가져옴
- 우수한 프로그래머와 설계자
    > 해법 영역과 문제 영역을 구분할 줄 알아야 함
## (16) 의미 있는 맥락을 추가하라
- 스스로 의미가 분명한 이름 사용
- 접두어를 사용해 `맥락`을 더 `분명`하게 만들 수 있음 
- `클래스`를 사용하면 더 좋음
## (17) 불필요한 맥락을 없애라
- 일반적으로 짧은 이름이 긴 이름보다 좋음(의미가 분명한 경우)
- Address 메서드보다 클래스에 적합
- 포트 주소, MAC 주소, 웹주소
    > PostalAddress, MAC, URI
- 의미를 분명하게 사용
## (18) 마치면서
- 읽히는 코드
    - 문장이나 문단처럼
    - 표나 자료구조처럼
- 코드를 개선하려는 노력을 중단해선 안됨

# 3장 함수
## (1) 작게 만들어라!
- 첫째 규칙 `작게`
- 둘째 규칙 `더 작게`
### 1) 블록과 들여쓰기
- if문, else문, while문 들어가는 블록은 한줄이어야 함
    - `함수`를 호출 함
- 중첩구조가 생길만큼 함수가 커져서는 안 됨
- 함수 들여쓰기 수준은 `1단`, `2단`이 적당
## (2) 한 가지만 해라!
- 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행
- 의미 있는 이름으로 다른 함수 추출
### 1) 함수 내 섹션
- 한가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어려움
## (3) 함수 당 추상화 수준은 하나로!
- 함수 내 모든 문장의 추상화 수준이 동일
- 추상화 수준이 섞이면 코드를 읽는 사람이 헷갈림
### 1) 위에서 아래로 코드 읽기: 내려가기 규칙
- 위에서 아래로 이야기처럼 읽혀야 함
## (4) Switch 문
- 작게 만들기 어려움
- 본질적으로 N가지 처리
- 다형성을 이용해 저차원 클래스에 숨기고 절대로 반복하지 않음
- 단일책임원칙 위반
    - 코드를 변경할 이유가 여러가지
- 개방폐쇄원칙 위반
    - 새 직원 유형을 추가할 때마다 코드를 변경해야함
    - switch문을 추상팩토리에 숨김
    - switch문에서 파생 클래스의 인스턴스를 생성
- 상속 관계를 숨긴후 절대로 다른 코드에 노출하지 않음
## (5) 서술적인 이름을 사용하라!
- 좋은이름은 함수가 하는 일을 좀더 잘 표현
- 모듈 내에서 함수이름은 같은문구, 명사, 동사를 사용
- 좋은예
    - includeSetupAndTeardownPages
    - includeSuiteSetupPage
    - includeSetupPages
    - includeSetupPage
## (6) 함수 인수
- 함수에서 이상적인 인수 개수는 0개(무항)
- 그 다음은 1개(단항)과 2개(이항)
- 3개(삼항)은 피하는 편이 좋음
- 테스트 관점 복잡해짐
    - 갖가지 인수 조합으로 함수 검증 필요
### 1) 많이 쓰는 단항 형식
1. 인수에 질문을 던지는 경우
    ```java
        boolean fileExists("MyFile")
    ```
2. 인수를 뭔가로 변환해 결과를 반환하는 경우
    ```java
        InputStream fileOpen("MyFile")
    ```
### 2) 플래그 인수
- 함수의 인자로 부울값을 넘기는 관례는 피해라
- 함수가 여러가지 처리한다고 공표하는 것과 같기 때문
- renderForSuite()과 renderForSingleTest()함수로 나누는게 좋음
### 3) 이항 함수
- 이항함수는 단항함수보다 이해하기 어려움
- assertEquals(expected, actual)
    - expected 인수에 actual 값을 집어넣으면 안됨
    - 인수의 순서를 기억애햐 함
- 단항함수로 바꾸도록 애써야 함
- 직교 좌표계 점은 일반적으로 인수 2개를 취함
### 4) 삼항 함수
- 이항함수보다 훨씬 어려움
- 신중히 고려할 것 권고
### 5) 인수 객체
- 인수가 2~3개 필요한 경우 일부를 클래스 변수로 선언 가능한지 살펴야 함
### 6) 인수 목록
- 인수 개수가 가변적인 함수도 필요
- 가변인수를 취하는 함수는 단항, 이항, 삼항 함수로 취급
- 삼항함수를 넘어서는 인수사용 문제
### 7) 동사와 키워드
- 좋은 함수 이름은 `함수의 의도`, `인수의 순서와 의도`를 제대로 표현
- 단항 함수
    - 함수와 인수(`동사/명사`)쌍을 이룸
    - write(name)
- `함수 이름에 키워드 사용`
    - assertExpectedEqualsActual(expected, actual)
    - 함수 이름에 인수를 넣어 인수 순서를 기억하지 않아도 됨
## (7) 부수 효과를 일으키지 마라!
- 부수효과
    - 함수에서 한가지를 하겠다고 약속하고 남몰래 다른일을 하는 것
    - 함수 이름과 상관없는 일은 지양
    - 시간적인 결합, 순서종속성 초래할 수 있음
- checkPasswordAndInitializeSession
    - 함수가 한가지만 한다는 규칙 위반함
        - 패스워드 확인과 세션 초기화를 같이 함
    - 시간적인 결합이 필요한 경우 명시하는 것이 좋음
### 1) 출력 인수
- 일반적으로
    - 인수를 `함수 입력`으로 해석
    - 출력인수는 피해야 함
- 객체지향 언어에서는 출력 인수를 사용할 필요가 거의 없음
- 출력인수로 사용하라고 설계한 변수
    - `this`
- 함수 상태 변경
    - 함수가 속한 `객체 상태`를 변경
## (8) 명령과 조회를 분리하라!
- 함수는 수행하거나 답하거나 둘 중 하나만 해야 함
- 객체 상태 변경, 객체 정보 반환
- 설정하는 코드인지 확인하는 코드인지 분간이 안감
    ```java
        if(set("username", "unclebob"))
    ```
- 명령과 조회를 분리해서 코드 작성
    ```java
        if(attributeExits("username")){
            setAttribute("username", "unclebob");
        }
    ```
## (9) 오류 코드보다 예외를 사용하라!
- 명령 함수에서 오류코드 반환하는 방식
    - 명령/조회 분리 규칙 미묘하게 위반
- 오류코드 대신 예외 사용
    - 오류처리코드가 원래 코드에서 분리되므로 코드가 깔끔해짐
### 1) Try/Catch 블록 뽑아내기
- 정상 동작과 오류 처리 동작을 뒤섞음
- try/catch 블록은 별도 함수로 뽑아내는 편이 좋음
### 2) 오류 처리도 한 가지 작업이다.
- 함수는 `한가지` 작업만 해야 함
- 오류처리도 한가지 작업임
- 오류만 처리해야함
### 3) Error.java 의존성 자석
- 오류코드 반환
    - 클래스나 열거형 변수나 어디선가 오류 코드를 정의하는 것
    - Error enum을 사용하는 클래스 전부를 다시 컴파일하고 재배치 해야 함
        - 번거롭기에 새 오류 코드 정의하는 것 추천하지 않음
- 기존 `오류코드 재사용`을 추천
- 예외 사용시 새 예외는 Exception 클래스에서 `파생`됨
    - `재컴파일, 재배치 없이` 새 예외클래스 추가할 수 있음
## (10) 반복하지 마라!
- 중복을 없애면 `모듈 가독성`이 높아짐
- 많은 원칙과 기법이 `중복을 제어`할 목적으로 나옴
- 관계형 데이터베이스 정규 형식
    - 중복제거 목적
- 객체지향 프로그래밍
    - 코드를 부모 클래스로 몰아 중복을 없앰
## (11) 구조적 프로그래밍
1. 구조적 프로그래밍 원칙
    - 모든 함수와 함수 내 모든 블록에 `입구와 출구가 하나만 존재`
    - 함수는 `return문이 하나여야 함`
    - 루프 안
        - break, continue, goto 사용 안할 것을 추천
    - 함수가 클 경우 이익 제공
    - 구조적 프로그래밍은 함수가 적으면 별 이익 없음
2. 함수가 작은 경우
    - return, break, continue 여러차례 사용해도 괜찮음
        - `단일 입/출구 규칙`보다 의도를 표현하기 쉬워짐
    - goto문은 큰 함수에서만 의미가 있음
        - 작은 함수에선 피해야 함
## (12) 함수를 어떻게 짜죠?
- 처음엔 길고 복잡함
- 코드를 다듬고 함수 만들고 이름 바꾸며 중복을 제거함
- 메서드 줄이고 순서를 바꿈
- 전체 클래스를 쪼개기도 함
- 코드를 빠짐없이 테스트하는 단위테스트를 만들고 통과함
## (13) 결론
- 대가 프로그래머
    - 시스템을 `구현할` 프로그램이 아니라 `풀어갈` 이야기로 여김
- 진짜 목표
    - 시스템이라는 이야기를 풀어가는 것
- 함수는 분명하고 정확한 언어로 깔끔하게 맞아 떨어져야 함
- 길이가 짧고, 이름이 좋고, 체계가 잡힘 함수
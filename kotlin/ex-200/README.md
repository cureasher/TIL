# ex-200
## 001. Hello Kotlin
   1. 메인함수 
        - `메인`(main)함수로 시작
   2. 기본 출력 함수
        - `println()`을 사용해 문자 출력
   3. Unit
        - `반환`하지 않음.

## 002. Expression
   1. 표현식
        - 수학 연산(덧셈, 뺄셈)
        - 연산자 왼쪽부터 계산
        
## 003. Variable
   1. 변수: 값을 저장하는 공간
      - var: 일반 변수 선언에 사용
      - val: 불변 변수
        > 선언된 변수는 값을 저장하면 나중에 값을 수정할 수 없다
   2. 표기법
      - 코틀린은 Carmel Case를 주로 사용
      - `Carmel Case`: 낙타 표기법
        > 첫글자 소문자로 시작, 단어 바뀔 때 첫 글자를 대문자로 표기
        ```kotlin
            anyVariableName
        ```
      - `Pascal Case`: 파스칼 표기법
        > 첫글자 대문자로 시작, 단어의 첫글자를 대문자로 표기
        ```kotlin
           AnyVariableName
        ```
      - `Snake Case`: 뱀 표기법
        > 소문자로 쓰고 단어를 쓰고 단어마다 _(언더바)로 구분해 표기
        ```kotlin
           any_variable_name
        ```
   3. 키워드
      - 코틀린 문법 상 정해 놓은 단어를 키워드로 구분
      - 키워드를 변수명으로 사용하면 안 됨
      - ex) fun, var, val, Int, String ...

## 004. LiteralDataType
   1. `리터럴` 타입
      - 리터럴 : 숫자 값 자체
      - 리터럴의 타입 `생략 가능`
      - 생략하더라도 자동으로 정수면 `정수 타입 적용`
          ```kotlin
              val variable = 10 + 12 - 5
          ```
          ```kotlin
              val variable : Int = 10 + 12 - 5
          ```
        
## 005. ArithmeticOperator
   1.  산술연산자
        - `가감승제`를 수행하는 연산자
        - 사칙연산 법칙을 따름
        
        기호   | 결과   
        :---: | :----: 
        \+     | 더하기
        \-     | 빼기
        \*     | 곱하기
        \/     | 몫
        \%     | 나머지

   2. 타입 변환
       - 정수형을 실수로 변환
         > toDouble()
       - 정수와 소수 계산시 정수에서 실수를 빼도 소수점 소실 됨
         > 피연산자 하나를 실수형으로 선언해주면 소수점 보존됨.
         
## 006. DecrementOperator
   1. 증감연산자
        - 전위 증가 연산자 : ++a
        - 후위 증가 연산자 : a++
        - 전위 감소 연산자 : --a
        - 후위 감소 연산자 : a--
            - 전위는 연산자 사용하기 전에 증가나 감소 진행 
            - 후위는 연산자 사용한 후에 증가나 감소 진행
            
## 007. Bitwise Operator
   1. 비트 연산자
        - 코틀린의 비트 연산자는 기호가 아닌 문자 사용
        - 비트 연산
          > 숫자를 2진수로 변환하여 계산

          > 각 자릿수 별로 비트 연산
              
              [풀이]      
              1111(15)
              0111(7)
              and 연산 : 0111(7)
              
              0101(5)
              0010(2)
              or 연사 : 0111(7)
  
            형태   | 비트연산
            :---: | :----
            and   | 비트가 서로 true일때 만 true
            or    | 비트가 하나라도 true이면 true
            xor   | 비트가 서로 다를 때만 true
            inv() | 비트 단위 반적
            shl   | 왼쪽 쉬프트
            shr   | 오른쪽 쉬프
            ushr | 부호를 유지한채 오른쪽 쉬프

## 008. IntegerAndRealDataType
   1. 정수타입(용량)
   
        타입이름 | 용량 | 저장 가능 범위
        :---:  | --- |  ---
        Byte | 1Byte | -128~127
        Short | 2Byte| -32768~32767
        Int| 8Byte | -2147483648<br>~2147483647
        Long |8Byte | -9223372036854775808<br>~9223372036854775807
   2. 실수타입(용량)
        - 부동소수점 방식

        타입이름 | 용량 | 저장 가능 범위
        :---:  | --- |  ---
        Float | 4Byte | 1.410-45<br>~3.40282351038
        Double | 4Byte| 4.910-324<br>~1.797693134862315710308
   3. 정수리터럴
        - 16진수 : `0X`로 시작
        - 2진수 : `0b`로 시작
        - 8진수 : 지원하지 않음
        
## 009. TrapOfRealNumber
   1. 실수 타입의 함정
        - 0.1f 3번 더하면 0.3이 나옴
        - 0.1f를 10번 더하면 1이 될걸로 예상할 수 있지만 엉뚱한 결과 출력 됨
        - 엉뚱한 값이 나올 수 있음.
        - 0.1f에 10을 곱하면 1.0이 나옴
        - 실수는 항상 대략적인 값만 얻을 수 있음.
        
## 010. CharType
   1. 문자타입
        - 문자를 저장할 수 있는 타입
        - 문자 한개만 저장할 수 있음
        - Char 타입의 크기는 2바이트
        - 문자 1개를 작은따옴표로 감쌈('A')
        - 문자코드 `유니코드` 사용
   2. 유니코드 범위
        - 0~65535
        - 16진수 (0~FFFF)
        
## 011. StringExample
   1. 문자열
        - 문자를 일렬로 나열한 것
        - String : 문자열을 저장할 수 있는 타입
        - 큰따옴표로 문자열을 감쌈
        - 문자열에 + 문자열을 쓰게 되면 문자열의 오른쪽에 문자열을 덧붙임
        - \n 줄바꿈 특수문자
        - []를 사용해 index로 문자 접근 가능

## 012. ExpressionString
   1. 문자열 표현식
        - 문자열 안에 표현식 값 집어넣기
        - 큰따옴표 안에 $뒤에 변수 이름 적으면 변수값으로 대체됨
        - 문법적 설탕 : 사람이 읽고 쓰기 좋게 추가적으로 제공하는 문법

## 013. TypeAlias
   1. 타입 별명
        - 형태
          > typealias 별명 = 타입      
        - 타입 이름이 길때 줄이는 용도로 사용
        
## 014. Comment
   1. 주석
        - 형태
            - 한줄 전체 주석 : `//`
            - 구간 주석 : `/* */`
        - 소스코드에 달아 놓는 메모
        - 코드를 `설명`하는 역할
        - 코드 임시 `비활성화`

## 015. AssignmentOperator
   1. 배정 연산자(`=`)
        - 변수에 값을 저장할 때 사용하는 연산자
        - 배정연산자와 일반연산자(`줄여 쓸 수 있음`)
           > a=a+3 -> a+=3

## 016. Statement
   1. 문장
        - 독립적으로 실행할 수 있는 코드 조각
   2. 문장 구분
        - 변수 선언
        - 변수에 값 대입
        - 출력문
   3. 여러 문장을 한줄로 연결(세미콜론(;)을 사용해 문장 연결)
        ```kotlin
              val num : Int
              num = 15
              println(num + 7 + 3)
              
              val num : Int; num = 15; println(num + 7 + 3)
        ```

## 017. ComparisonOperator
   1. 비교 연산자
        - 두 피연산자를 비교하는 연산자
        - 결과타입 : Boolean 타입 참(true)과 거짓(false)
        - 객체 참조값 비교 : ===, !==

            기호   | 사용 예   | 뜻
            :---: |  :---:  | ---
            ==    |  a == b | 같으면 true, 다르면 false
            !=    |  a != b | a와 b가 다르면 true, 같으면 false
            \>    |  a \> b | a가b보다 크면 true, 그렇지 않으면 false
            <     |  a < b  | a가b보다 작으면 true, 그렇지 않으면 false
            \>=   | a \>= b | a가b보다 크거나 같으면 true, 그렇지 않으면 false
            <=    |  a <= b | a가b보다 작거나 같으면 true, 그렇지 않으면 false

## 018. LogicalOperator
   1. 논리연산자
        - 참과 거짓으로만 계산을 수행하는 연산자

            기호   | 사용 예   | 뜻
            :---: |  :---:  | ---
            &&    | a && b  | a와 b가 모두  true 일때 true 하나라도 false있으면 false
            !     | !a      | a가 true면 결과값은 false, a가 false면 결과값은 true
            
            a \|\| b : a와 b중 하나라도 true면 true 둘다 false 여야 false
           ```kotlin
               val a2 = 10
               var isTrue = 5 < a < 15 // 잘못된 코드
               val isTrue = 5 < a &&  a < 15 // 동작하는 코드
          ```
          
          `오류`
          > The integer literal does not conform to the expected type Boolean(정수 리터럴이 예상되는 타입은 Boolean 을 따르지 않는다.)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   > 
## 019. ExIf
   1. 조건문(if)
        - `조건문` Boolean 타입 표현식
        - 블록 : { }
            - 여러개의 문장 담을 때 사용
        - 조건이 참일때만 if문 안의 문장 실행
        - if문에 속한 문장이 하나일때 중괄호 생략 가능
            ```kotlin
                if( a > b) {
                    println(a)
                }
                // 중괄호 생략
                if( a > b)
                    println(a)
            ```               
            
## 020. ExIfElse
   1. If-else
        - else :if문의 조건이 false일때 실행하는 문장
        - if부터 else까지 하나의 문장으로 인식함

## 021. GradeIfElse
   1. if와 else문의 중첩
        - if문 안에 또 다른 is-else문을 넣을수 있음.
        - else 문에 if를 붙여서 축약 가능
        
## 022. IfExpression
   1. if 표현식
        - if와 else문이 모두 갖춰져 있으면 if-else 부분 전체가 표현식이 됨
        - 결과 값이 변수에 저장 됨
        - if 블록과 else 블록은 표현식 타입이 일치해야 함
        - 비어있거나 마지막 문장이 표현식이 아니면 Unit 타입이 된다. 의미 없는 값이 저장됨
        - 코드에서 10은 출력문이 없지만 표현식으로 값이 저장되어 출력 됨
        
## 023. GradeWhen
   1. when문
        - 조건에 따라 문장 실행 여부를 결정하는 키워드
        - 쉼표를 이용해 비교할 값 여러개 지정 가능
        - 조건이 맞으면 문장을 실행하고 빠져 나옴.
        
## 024. GradeWhenExpression
   1. when 표현식
        - 표현식으로 출력문 없이 값 전달 가능
        - when문 문장 안에 조건이 맞으면 결과값 나오게 사용 가능
        
## 025. OneToTenWhile
   1. while문
        - 특정 문장을 반복할 때 사용하는 키워드
        - 조건이 참일 동안 문장 수행
        - 조건이 계속 참일 경우 무한루프에 빠지게

## 026. OneExecutedDoWhile
   1. do-while문
        - 한번은 무조건 실행
        - 문장 마지막에 조건을 검사
        
## 027. OddPrintContinue
   1. continue
        - 반복문의 일부 문장을 무시하고 건너 뜀

## 028. OneToFiveBreak
   1. break
        - 반복문 실행 중 반복문을 빠져나오는 용도
        - 가장 가까운 반복문을 빠져 나갈 수 있음
        
## 029. TenAndFiveLabel
   1. label
        - 중첩된 반복문에서 한번에 나올 때 사용
        - 원하는 결과값을 얻으려면 빠져나와야 하나 계속 증가하므로 오답이 나올 수 있음
        - label을 사용하지 않으면 결과값은 x=21, y=21 나옴

## 030. AddFunction
   1. 함수(function)
        - 명령어를 담는 상자
        - `fun` 키워드
        - 함수 속의 문장이 순차적으로 실행
        - 함수의 반환값과 숫자를 더할 수 있음
    2. 함수 간단히 쓰기
        ```kotlin
              fun DoubleFunction(): Dobule
              {
                  return 3.0 + 7
              }         
              // 문장이 하나일 경우 중괄호와 타입 생략하고 한줄 축약 가
              fun DoubleFunction() = 3.0 +7
      
        ```

## 031. FahrenheitChange
   1. 매개변수와 인수
        -  매개변수
            - 함수를 호출한 곳으로부터 값을 전달받을 때 사용
            - 선언할 때 var, val 키워드 붙이지 않음
            - val로 선언되므로 값 수정 불가
        - 인수
            - 매개변수에 저장되는 표현식
        - 매개변수의 타입과 인수의 타입은 일치야 함

## 032. CelsiusChange
   1. `Unit` 타입
        - 반환 값을 가지지 않는 클래스
        - 생략하면 자동으로 Unit 적용 됨
        

## 033. DefaultArgument
   1. `디폴트 인수`
        - 함수 만들때 매개변수 없으면 입력안하고 호출 가
        - `함수호출` 인수를 입력해야 됨
        - 매개변수에 디폴트 값 지정 
        - 선언과 동시에 디폴트 값으로 초기화 하면 인수를 지정하지 않아도 됨
        - 매개변수 이름을 직접 지정하면 `인수 위치 변경` 가능
        - 매개변수 입력시 `타입도 같이 지정`해야 함.(지정안할 경우 에러 발생)
        - 오류
            > Mixing named and positioned arguments is not allowed(이름이 지정된 인수와 일반인수 같이 사용 할 수 없음)
        
## 034. VariableArgumentSum
   1. 가변인수
        - `N개의 인수` 받는 함수
        - `vararg` 키워드 사용
        - 일반인수와 같이 사용 가능
        - 아무 인수 지정하지 않을 수 있음(인수 없을 경우 0이 됨)
        - 일반인수와 같이 사용시 일반인수가 오른쪽에 있으면 매개변수 이름 붙여야 함
        - 일반인수와 함께 쓸때 일반인수 먼저 적고 N개의 인수 적으면 호출 가능 
        
## 035. FunctionOverloading
   1. `함수 오버로딩`
        - 이름이 같은 함수를 여러개 선언하는 것
        - 함수이름이 같아도 매개변수가 타입 다르면 사용가능
        - println 함수에 윈도우 `ctrl`, 맥 `command` 버튼 누르고 클릭시 Console.kt에서 오버로딩 메서드 확인 가능
        
## 036. LocalAndGlobalVariable
   1. `지역변수`
        - 블록 안에서 선언된 변수
   2. `전역변수`
        - 함수 밖에서 선언한 변수 
   3. `스코프`
        - 변수가 인식될 수 있는 범위

## 037. OverlapVariable
   1. 중복되는 변수 사용
        - 한 블록 안에선 변수 이름 중복 안됨
        - 지역변수와 전역변수 이름은 중복 가능
        - 가장 가까운 스코프의 변수 인식
        
## 038. OtherFunctionLocalVariable
   1. 다른 함수의 지역변수 사용
        - 다른 함수에 있으면 스코프가 다르므로 중복 가능

## 039. LocalFunction
   1. 지역함수
        - 함수 속에 함수가 있는 것
        - 블록 안에 선언된 함수
        
## 040. MemoryStackArea
   1. 메모리의 스택 영역
        - `스택` : 변수가 생성될 때 생성된 순서대로 쌓임
        - 매개변수들이 생성되고 사라짐 
        - 변수 선언 
        - 앱솔루트 함수 호출
        - 앱솔루트 매개변수 쌓임
        - 메인함수가 끝나면 모든 지역변수가 스택 영역에서 사라     
        - 스택 영역
            - main 함수 시작
            - args 변수 생성
            - first 변수 생성
            - absolute 함수 시작
            - second 변수 생성
            - 조건 확인 후 실행
            - second 변수가 종료
            - absolute 함수 종료
            - result 변수 생성되며 저장된 값 출력
            - main 함수 종료되며 스택 영역에서 모든 지역변수 사라짐
            
## 041-1. MathFunction
   1. 수학함수
        - 최대값
        - 최소값
        - 절대값

## 041-2. MathFunctionUse
   1. 수학함수 사용
        - 같은 폴더에 있는 함수 사용
        
## 042. package 생성
   1. 패키지
        - 소스파일 관리하는 폴더
        
## 043. AnotherPackageUse
   1. 다른 패키지 사용
        - 패키지명 적고 함수 접근 및 사용 가능
        
## 044. ImportUse
   1. 패키지 접근없이 사용가능
        - `import`로 패키지 경로 추가후 패키지 이름없이 접근 가능
        - 패키지 import 후 as 붙이고 이름 변경 가능
        
## 045. PersonObject
   1. `객체`
        - 서로 연관 있는 변수를 묶어놓은 데이터
        - 객체는 각자 고유한 `속성`과 `동작`을 갖고 있음.
   2. example
        - 가방 : 용량, 색상
        - 사람 : 이름, 나이, 말하기(동작)

## 046. HeapAreaAnimal
   1. Heap 영역 : 스택과는 다른 메모리 영역,객체가 만들어지는 공간
        - person 변수가 스택에 생성
        - object 부분이 실행되며 힙영역에 객체 생성
        
   2. 참조변수(Reference Variable) : 객체의 좌표를 저장하는 변수
        - animal 변수 
   3. 참조 값 : 객체의 좌푯값 

## 047. PersonClass
   1. class
        - 객체를 찍어내기 위한 설계도
   2. Java와 Kotlin의 차이
        - Java
            - public 클래스를 선언하면 클래스 이름이 파일이름과 같아야 함.
            - 파일 하나당 한개만 존재할 수 있음
            - 객체를 생성할 때 new 키워드 필요
        - Kotlin
            - 클래스 이름이 파일이름과 같지 않아도 됨
            - 한 파일 내에 여러개의 public 클래스 선언 가능
            - new 키워드 없이 생성자 이름만으로 객체 생성 가능
   3. 인스턴스(Instance)
        - 클래스로부터 생성된 객체
        - 클래스라는 틀로부터 구체적으로 만들어 짐

## 048. ProductHeap
   1. Heap 영역 참조 활용
        - 메인함수 생성
        - 객체 생성되며 변수 선언이 이루어짐(args, product)
        - createProduct 함수 생성
        - apple 변수 생성
        - 힙 영역에 값 apple 변수에 참조
        - 참조변수가 가리키는 객체 프로퍼티에 값을 넣음
        - 참조값 반환하며 함수 종료
        - 힙영역엔 참조값이 저장되어 있음
        - 스택은 지워지지만 힙에는 남아 있음
        - 힙 영역에 생성한 변수는 블록을 빠져나와도 지워지지 않음
        - 객체를 여러 참조 변수에서 공유 형태로 사용 가능(메모리 절약 됨)

## 049. HelloWorldHeap
   1. 문자열 연산시 주의
        - 문자열은 `힙영역에서 생성됨`
        - String 변수는 문자열의 참조값을 저장하기 위한 공간맞 갖고 있음
        - 문자열끼리 '+' 연산시 새로운 문자열이 덧붙는게 아님
        - 힙 영역에 기존 문자열은 남고 함쳐진 문자열 새로 생성
        - 남은 문자열에 다시 접근할 방법 없음(해결법 : `가비지 컬렉션`)
        - 접근할수 없는 메모리가 계속 쌓이면 문제가 됨
        
## 050. GarbageCollection
   1. `가비지 컬렉션`
        - 미아 객체 : 참조변수로 힙영역에 생성되었다가 참조가 끊기게 되면 생기는 객체
        - 미아 객체가 힙에 많이 쌓이면 적당한 시점에 자동으로 가비지 컬렉션 수행함.
        - 미아가 된 객체는 메모리 공간이 부족해지면 가비지 컬렉션 기능에 의해 소멸
   2. `프리징 현상`
        - 가비지 컬렉션이 일어날때 미아객체를 탐색해야하므로 순간적으로 프로그램이 멈추는 현상 일어날 수 있음
        
## 051. TripleEquals
   1. 참조변수
        - `===` : 두 참조 변수가 같은 객체를 가리키는지 조사하는 연산자로 같으면 true, 다르면 false
        - `!==` : 두 참조 변수가 다른 객체를 가리키면 true, 아닌 경우 false
        - `==` : 자바의 equals메서드 호출한것과 같음
        

## 052. Building
   1. `멤버함수`
        - 클래스에 내장된 함수
        - 객체의 동작 역할
   2. `멤버`
        - 프로퍼티, 멤범함수를 간단하게 멤버라고 부름
        
## 053. ThisDuplication
   1. this 사용
        - 클래스 프로퍼티와 멤버함수의 변수가 같을 경우 구별하기 위해 사용
        - `this` 키워드 : 클래스의 프로퍼티 인식
        - 프로퍼티 이름이 중복되지 않을 경우 그냥 호출 가능 
        
## 054. Constructor
   1. `constructor`
        - 생성자
          > 클래스 생성시 자동으로 생성되는 함수          
        - 객체를 초기화 할 수 있음    
        - constructor 키워드 생략 가능
        - 생성자를 정의하지 않으면 매개변수 없는 기본 생성자 자동 생성
   2. `initializer`
        - 초기화
          > 객체의 프로퍼티 값 생
        - 생성자의 매개변수는 init 블록 내부에서 사용
        - 프로퍼티를 선언과 동시에 초기화 안해도 됨
   
## 055. Initializer
   1. init 블록
         - 순서대로 실행 됨
         - 여러개로 나누어 쓸 수 있
 
## 056. PropertyInConstructor
   1. 생성자 프로퍼티
        - 클래스 생성시 매개변수를 바로 초기화
        - 클래스 내용 없는 경우 중괄호 생략 가능
        
## 057. SecondaryConstructor
   1. Constructor
        - `주생성자`: 클래스 이름 옆에오는 생성자(생략 가능)
        - `보조생성자`: 클래스 내부에 오는 생성자, 여러개 올 수 있음
        - this: 클래스에 포함된 또 다른 생성자 호출는 문법
        
## 058. PropertyGetterSetter
   1. `getter`
        - 저장된 값을 읽으려할 때 호출되는 함수
        - 생략해도 디폴트 getter가 있음     
   2. `setter`
        - 값을 저장하려고 할때 호출되는 함수  
        - 생략해도 디폴트 setter가 있음     
   3. `val` 프로퍼티
        - getter만 존재함
        - 초기값이 주어지면 더이상 값을 변경할 수 없음
   
## 059. OperatorOverloading
   1. 연산자 오버로딩
        - 숫자 타입끼리는 연산자 사용 가능
        - 클래스 끼리 연산하려면 오버로딩 필요

## 060. AccessOperator
   1. `접근연산자`('[]')
        - 문자열 다룰 때 사용
        - 객체의 일부 값 출력 가능
        - 객체 값 입력 방법
        ```kotlin
              // 입력방법1
              birthday[0] = "Java"
              // 입력방법2
              birthday.set(0, "Java")
        ```
      
## 061. InvokeOperator
   1. `호출연산자`('()')
        -  : 함수를 호출 할 때 사용하는 연산자
        - invoke : 오버로딩 멤버함수
        - 인수 개수 자유
        - 인수 생략 가능
        



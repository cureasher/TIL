# ex-200
## 001. Hello Kotlin
   1. 메인함수 
        - `메인`(main)함수로 시작
   2. 기본 출력 함수
        - `println()`을 사용해 문자 출력
   3. Unit
        - `반환`하지 않음.

## 002. Expression
   1. 표현식
        - 수학 연산(덧셈, 뺄셈)
        - 연산자 왼쪽부터 계산
        
## 003. Variable
   1. 변수: 값을 저장하는 공간
      - var: 일반 변수 선언에 사용
      - val: 불변 변수
        > 선언된 변수는 값을 저장하면 나중에 값을 수정할 수 없다
   2. 표기법
      - 코틀린은 Carmel Case를 주로 사용
      - `Carmel Case`: 낙타 표기법
        > 첫글자 소문자로 시작, 단어 바뀔 때 첫 글자를 대문자로 표기
        ```kotlin
            anyVariableName
        ```
      - `Pascal Case`: 파스칼 표기법
        > 첫글자 대문자로 시작, 단어의 첫글자를 대문자로 표기
        ```kotlin
           AnyVariableName
        ```
      - `Snake Case`: 뱀 표기법
        > 소문자로 쓰고 단어를 쓰고 단어마다 _(언더바)로 구분해 표기
        ```kotlin
           any_variable_name
        ```
   3. 키워드
      - 코틀린 문법 상 정해 놓은 단어를 키워드로 구분
      - 키워드를 변수명으로 사용하면 안 됨
      - ex) fun, var, val, Int, String ...

## 004. LiteralDataType
   1. `리터럴` 타입
      - 리터럴 : 숫자 값 자체
      - 리터럴의 타입 `생략 가능`
      - 생략하더라도 자동으로 정수면 `정수 타입 적용`
          ```kotlin
              val variable = 10 + 12 - 5
          ```
          ```kotlin
              val variable : Int = 10 + 12 - 5
          ```
        
## 005. ArithmeticOperator
   1.  산술연산자
        - `가감승제`를 수행하는 연산자
        - 사칙연산 법칙을 따름
        
        기호   | 결과   
        :---: | :----: 
        \+     | 더하기
        \-     | 빼기
        \*     | 곱하기
        \/     | 몫
        \%     | 나머지

   2. 타입 변환
       - 정수형을 실수로 변환
         > toDouble()
       - 정수와 소수 계산시 정수에서 실수를 빼도 소수점 소실 됨
         > 피연산자 하나를 실수형으로 선언해주면 소수점 보존됨.
         
## 006. DecrementOperator
   1. 증감연산자
        - 전위 증가 연산자 : ++a
        - 후위 증가 연산자 : a++
        - 전위 감소 연산자 : --a
        - 후위 감소 연산자 : a--
            - 전위는 연산자 사용하기 전에 증가나 감소 진행 
            - 후위는 연산자 사용한 후에 증가나 감소 진행
            
## 007. Bitwise Operator
   1. 비트 연산자
        - 코틀린의 비트 연산자는 기호가 아닌 문자 사용
        - 비트 연산
          > 숫자를 2진수로 변환하여 계산

          > 각 자릿수 별로 비트 연산
              
              [풀이]      
              1111(15)
              0111(7)
              and 연산 : 0111(7)
              
              0101(5)
              0010(2)
              or 연사 : 0111(7)
  
            형태   | 비트연산
            :---: | :----
            and   | 비트가 서로 true일때 만 true
            or    | 비트가 하나라도 true이면 true
            xor   | 비트가 서로 다를 때만 true
            inv() | 비트 단위 반적
            shl   | 왼쪽 쉬프트
            shr   | 오른쪽 쉬프트
            ushr  | 부호 유지한 오른쪽 쉬프트

## 008. IntegerAndRealDataType
   1. 정수타입(용량)
   
        타입이름 | 용량 | 저장 가능 범위
        :---: | ---   |  ---
        Byte  | 1Byte | -128~127
        Short | 2Byte | -32768~32767
        Int   | 4Byte | -2147483648<br>~2147483647
        Long  | 8Byte | -9223372036854775808<br>~9223372036854775807
   2. 실수타입(용량)
        - 부동소수점 방식

        타입이름 | 용량 | 저장 가능 범위
        :---:  | --- |  ---
        Float  | 4Byte | 1.410-45<br>~3.40282351038
        Double | 8Byte| 4.910-324<br>~1.797693134862315710308
   3. 정수리터럴
        - 16진수 : `0X`로 시작
        - 2진수 : `0b`로 시작
        - 8진수 : 지원하지 않음
        
## 009. TrapOfRealNumber
   1. 실수 타입의 함정
        - 0.1f 3번 더하면 0.3이 나옴
        - 0.1f를 10번 더하면 1이 될걸로 예상할 수 있지만 엉뚱한 결과 출력 됨
        - 엉뚱한 값이 나올 수 있음.
        - 0.1f에 10을 곱하면 1.0이 나옴
        - 실수는 항상 대략적인 값만 얻을 수 있음.
        
## 010. CharType
   1. 문자타입
        - 문자를 저장할 수 있는 타입
        - 문자 한개만 저장할 수 있음
        - Char 타입의 크기는 2바이트
        - 문자 1개를 작은따옴표로 감쌈('A')
        - 문자코드 `유니코드` 사용
   2. 유니코드 범위
        - 0~65535
        - 16진수 (0~FFFF)
        
## 011. StringExample
   1. 문자열
        - 문자를 일렬로 나열한 것
        - String : 문자열을 저장할 수 있는 타입
        - 큰따옴표로 문자열을 감쌈
        - 문자열에 + 문자열을 쓰게 되면 문자열의 오른쪽에 문자열을 덧붙임
        - \n 줄바꿈 특수문자
        - []를 사용해 index로 문자 접근 가능

## 012. ExpressionString
   1. 문자열 표현식
        - 문자열 안에 표현식 값 집어넣기
        - 큰따옴표 안에 $뒤에 변수 이름 적으면 변수값으로 대체됨
        - 문법적 설탕 : 사람이 읽고 쓰기 좋게 추가적으로 제공하는 문법

## 013. TypeAlias
   1. 타입 별명
        - 형태
          > typealias 별명 = 타입      
        - 타입 이름이 길때 줄이는 용도로 사용
        
## 014. Comment
   1. 주석
        - 형태
            - 한줄 전체 주석 : `//`
            - 구간 주석 : `/* */`
        - 소스코드에 달아 놓는 메모
        - 코드를 `설명`하는 역할
        - 코드 임시 `비활성화`

## 015. AssignmentOperator
   1. 배정 연산자(`=`)
        - 변수에 값을 저장할 때 사용하는 연산자
        - 배정연산자와 일반연산자(`줄여 쓸 수 있음`)
           > a=a+3 -> a+=3

## 016. Statement
   1. 문장
        - 독립적으로 실행할 수 있는 코드 조각
   2. 문장 구분
        - 변수 선언
        - 변수에 값 대입
        - 출력문
   3. 여러 문장을 한줄로 연결(세미콜론(;)을 사용해 문장 연결)
        ```kotlin
              val num : Int
              num = 15
              println(num + 7 + 3)
              
              val num : Int; num = 15; println(num + 7 + 3)
        ```

## 017. ComparisonOperator
   1. 비교 연산자
        - 두 피연산자를 비교하는 연산자
        - 결과타입 : Boolean 타입 참(true)과 거짓(false)
        - 객체 참조값 비교 : ===, !==

            기호   | 사용 예   | 뜻
            :---: |  :---:  | ---
            ==    |  a == b | 같으면 true, 다르면 false
            !=    |  a != b | a와 b가 다르면 true, 같으면 false
            \>    |  a \> b | a가b보다 크면 true, 그렇지 않으면 false
            <     |  a < b  | a가b보다 작으면 true, 그렇지 않으면 false
            \>=   | a \>= b | a가b보다 크거나 같으면 true, 그렇지 않으면 false
            <=    |  a <= b | a가b보다 작거나 같으면 true, 그렇지 않으면 false

## 018. LogicalOperator
   1. 논리연산자
        - 참과 거짓으로만 계산을 수행하는 연산자

            기호   | 사용 예   | 뜻
            :---: |  :---:  | ---
            &&    | a && b  | a와 b가 모두  true 일때 true 하나라도 false있으면 false
            !     | !a      | a가 true면 결과값은 false, a가 false면 결과값은 true
            
            a \|\| b : a와 b중 하나라도 true면 true 둘다 false 여야 false
           ```kotlin
               val a2 = 10
               var isTrue = 5 < a < 15 // 잘못된 코드
               val isTrue = 5 < a &&  a < 15 // 동작하는 코드
          ```
          
          `오류`
          > The integer literal does not conform to the expected type Boolean(정수 리터럴이 예상되는 타입은 Boolean 을 따르지 않는다.)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   > 
## 019. ExIf
   1. 조건문(if)
        - `조건문` Boolean 타입 표현식
        - 블록 : { }
            - 여러개의 문장 담을 때 사용
        - 조건이 참일때만 if문 안의 문장 실행
        - if문에 속한 문장이 하나일때 중괄호 생략 가능
            ```kotlin
                if( a > b) {
                    println(a)
                }
                // 중괄호 생략
                if( a > b)
                    println(a)
            ```               
            
## 020. ExIfElse
   1. If-else
        - else :if문의 조건이 false일때 실행하는 문장
        - if부터 else까지 하나의 문장으로 인식함

## 021. GradeIfElse
   1. if와 else문의 중첩
        - if문 안에 또 다른 is-else문을 넣을수 있음.
        - else 문에 if를 붙여서 축약 가능
        
## 022. IfExpression
   1. if 표현식
        - if와 else문이 모두 갖춰져 있으면 if-else 부분 전체가 표현식이 됨
        - 결과 값이 변수에 저장 됨
        - if 블록과 else 블록은 표현식 타입이 일치해야 함
        - 비어있거나 마지막 문장이 표현식이 아니면 Unit 타입이 된다. 의미 없는 값이 저장됨
        - 코드에서 10은 출력문이 없지만 표현식으로 값이 저장되어 출력 됨
        
## 023. GradeWhen
   1. when문
        - 조건에 따라 문장 실행 여부를 결정하는 키워드
        - 쉼표를 이용해 비교할 값 여러개 지정 가능
        - 조건이 맞으면 문장을 실행하고 빠져 나옴.
        
## 024. GradeWhenExpression
   1. when 표현식
        - 표현식으로 출력문 없이 값 전달 가능
        - when문 문장 안에 조건이 맞으면 결과값 나오게 사용 가능
        
## 025. OneToTenWhile
   1. while문
        - 특정 문장을 반복할 때 사용하는 키워드
        - 조건이 참일 동안 문장 수행
        - 조건이 계속 참일 경우 무한루프에 빠지게

## 026. OneExecutedDoWhile
   1. do-while문
        - 한번은 무조건 실행
        - 문장 마지막에 조건을 검사
        
## 027. OddPrintContinue
   1. continue
        - 반복문의 일부 문장을 무시하고 건너 뜀

## 028. OneToFiveBreak
   1. break
        - 반복문 실행 중 반복문을 빠져나오는 용도
        - 가장 가까운 반복문을 빠져 나갈 수 있음
        
## 029. TenAndFiveLabel
   1. label
        - 중첩된 반복문에서 한번에 나올 때 사용
        - 원하는 결과값을 얻으려면 빠져나와야 하나 계속 증가하므로 오답이 나올 수 있음
        - label을 사용하지 않으면 결과값은 x=21, y=21 나옴

## 030. AddFunction
   1. 함수(function)
        - 명령어를 담는 상자
        - `fun` 키워드
        - 함수 속의 문장이 순차적으로 실행
        - 함수의 반환값과 숫자를 더할 수 있음
    2. 함수 간단히 쓰기
        ```kotlin
              fun DoubleFunction(): Dobule
              {
                  return 3.0 + 7
              }         
              // 문장이 하나일 경우 중괄호와 타입 생략하고 한줄 축약 가
              fun DoubleFunction() = 3.0 +7
      
        ```

## 031. FahrenheitChange
   1. 매개변수와 인수
        -  매개변수
            - 함수를 호출한 곳으로부터 값을 전달받을 때 사용
            - 선언할 때 var, val 키워드 붙이지 않음
            - val로 선언되므로 값 수정 불가
        - 인수
            - 매개변수에 저장되는 표현식
        - 매개변수의 타입과 인수의 타입은 일치야 함

## 032. CelsiusChange
   1. `Unit` 타입
        - 반환 값을 가지지 않는 클래스
        - 생략하면 자동으로 Unit 적용 됨
        

## 033. DefaultArgument
   1. `디폴트 인수`
        - 함수 만들때 매개변수 없으면 입력안하고 호출 가능
        - `함수호출` 인수를 입력해야 됨
        - 매개변수에 디폴트 값 지정 
        - 선언과 동시에 디폴트 값으로 초기화 하면 인수를 지정하지 않아도 됨
        - 매개변수 이름을 직접 지정하면 `인수 위치 변경` 가능
        - 매개변수 입력시 `타입도 같이 지정`해야 함.(지정안할 경우 에러 발생)
        - 오류
            > Mixing named and positioned arguments is not allowed(이름이 지정된 인수와 일반인수 같이 사용 할 수 없음)
        
## 034. VariableArgumentSum
   1. 가변인수
        - `N개의 인수` 받는 함수
        - `vararg` 키워드 사용
        - 일반인수와 같이 사용 가능
        - 아무 인수 지정하지 않을 수 있음(인수 없을 경우 0이 됨)
        - 일반인수와 같이 사용시 일반인수가 오른쪽에 있으면 매개변수 이름 붙여야 함
        - 일반인수와 함께 쓸때 일반인수 먼저 적고 N개의 인수 적으면 호출 가능 
        
## 035. FunctionOverloading
   1. `함수 오버로딩`
        - 이름이 같은 함수를 여러개 선언하는 것
        - 함수이름이 같아도 매개변수가 타입 다르면 사용가능
        - println 함수에 윈도우 `ctrl`, 맥 `command` 버튼 누르고 클릭시 Console.kt에서 오버로딩 메서드 확인 가능
        
## 036. LocalAndGlobalVariable
   1. `지역변수`
        - 블록 안에서 선언된 변수
   2. `전역변수`
        - 함수 밖에서 선언한 변수 
   3. `스코프`
        - 변수가 인식될 수 있는 범위

## 037. OverlapVariable
   1. 중복되는 변수 사용
        - 한 블록 안에선 변수 이름 중복 안됨
        - 지역변수와 전역변수 이름은 중복 가능
        - 가장 가까운 스코프의 변수 인식
        
## 038. OtherFunctionLocalVariable
   1. 다른 함수의 지역변수 사용
        - 다른 함수에 있으면 스코프가 다르므로 중복 가능

## 039. LocalFunction
   1. 지역함수
        - 함수 속에 함수가 있는 것
        - 블록 안에 선언된 함수
        
## 040. MemoryStackArea
   1. 메모리의 스택 영역
        - `스택` : 변수가 생성될 때 생성된 순서대로 쌓임
        - 매개변수들이 생성되고 사라짐 
        - 변수 선언 
        - 앱솔루트 함수 호출
        - 앱솔루트 매개변수 쌓임
        - 메인함수가 끝나면 모든 지역변수가 스택 영역에서 사라     
        - 스택 영역
            - main 함수 시작
            - args 변수 생성
            - first 변수 생성
            - absolute 함수 시작
            - second 변수 생성
            - 조건 확인 후 실행
            - second 변수가 종료
            - absolute 함수 종료
            - result 변수 생성되며 저장된 값 출력
            - main 함수 종료되며 스택 영역에서 모든 지역변수 사라짐
            
## 041-1. MathFunction
   1. 수학함수
        - 최대값
        - 최소값
        - 절대값

## 041-2. MathFunctionUse
   1. 수학함수 사용
        - 같은 폴더에 있는 함수 사용
        
## 042. package 생성
   1. 패키지
        - 소스파일 관리하는 폴더
        
## 043. AnotherPackageUse
   1. 다른 패키지 사용
        - 패키지명 적고 함수 접근 및 사용 가능
        
## 044. ImportUse
   1. 패키지 접근없이 사용가능
        - `import`로 패키지 경로 추가후 패키지 이름없이 접근 가능
        - 패키지 import 후 as 붙이고 이름 변경 가능
        
## 045. PersonObject
   1. `객체`
        - 서로 연관 있는 변수를 묶어놓은 데이터
        - 객체는 각자 고유한 `속성`과 `동작`을 갖고 있음.
   2. example
        - 가방 : 용량, 색상
        - 사람 : 이름, 나이, 말하기(동작)

## 046. HeapAreaAnimal
   1. Heap 영역 : 스택과는 다른 메모리 영역,객체가 만들어지는 공간
        - person 변수가 스택에 생성
        - object 부분이 실행되며 힙영역에 객체 생성
        
   2. 참조변수(Reference Variable) : 객체의 좌표를 저장하는 변수
        - animal 변수 
   3. 참조 값 : 객체의 좌푯값 

## 047. PersonClass
   1. class
        - 객체를 찍어내기 위한 설계도
   2. Java와 Kotlin의 차이
        - Java
            - public 클래스를 선언하면 클래스 이름이 파일이름과 같아야 함.
            - 파일 하나당 한개만 존재할 수 있음
            - 객체를 생성할 때 new 키워드 필요
        - Kotlin
            - 클래스 이름이 파일이름과 같지 않아도 됨
            - 한 파일 내에 여러개의 public 클래스 선언 가능
            - new 키워드 없이 생성자 이름만으로 객체 생성 가능
   3. 인스턴스(Instance)
        - 클래스로부터 생성된 객체
        - 클래스라는 틀로부터 구체적으로 만들어 짐

## 048. ProductHeap
   1. Heap 영역 참조 활용
        - 메인함수 생성
        - 객체 생성되며 변수 선언이 이루어짐(args, product)
        - createProduct 함수 생성
        - apple 변수 생성
        - 힙 영역에 값 apple 변수에 참조
        - 참조변수가 가리키는 객체 프로퍼티에 값을 넣음
        - 참조값 반환하며 함수 종료
        - 힙영역엔 참조값이 저장되어 있음
        - 스택은 지워지지만 힙에는 남아 있음
        - 힙 영역에 생성한 변수는 블록을 빠져나와도 지워지지 않음
        - 객체를 여러 참조 변수에서 공유 형태로 사용 가능(메모리 절약 됨)

## 049. HelloWorldHeap
   1. 문자열 연산시 주의
        - 문자열은 `힙영역에서 생성됨`
        - String 변수는 문자열의 참조값을 저장하기 위한 공간맞 갖고 있음
        - 문자열끼리 '+' 연산시 새로운 문자열이 덧붙는게 아님
        - 힙 영역에 기존 문자열은 남고 함쳐진 문자열 새로 생성
        - 남은 문자열에 다시 접근할 방법 없음(해결법 : `가비지 컬렉션`)
        - 접근할수 없는 메모리가 계속 쌓이면 문제가 됨
        
## 050. GarbageCollection
   1. `가비지 컬렉션`
        - 미아 객체 : 참조변수로 힙영역에 생성되었다가 참조가 끊기게 되면 생기는 객체
        - 미아 객체가 힙에 많이 쌓이면 적당한 시점에 자동으로 가비지 컬렉션 수행함.
        - 미아가 된 객체는 메모리 공간이 부족해지면 가비지 컬렉션 기능에 의해 소멸
   2. `프리징 현상`
        - 가비지 컬렉션이 일어날때 미아객체를 탐색해야하므로 순간적으로 프로그램이 멈추는 현상 일어날 수 있음
        
## 051. TripleEquals
   1. 참조변수
        - `===` : 두 참조 변수가 같은 객체를 가리키는지 조사하는 연산자로 같으면 true, 다르면 false
        - `!==` : 두 참조 변수가 다른 객체를 가리키면 true, 아닌 경우 false
        - `==` : 자바의 equals메서드 호출한것과 같음
        

## 052. Building
   1. `멤버함수`
        - 클래스에 내장된 함수
        - 객체의 동작 역할
   2. `멤버`
        - 프로퍼티, 멤범함수를 간단하게 멤버라고 부름
        
## 053. ThisDuplication
   1. this 사용
        - 클래스 프로퍼티와 멤버함수의 변수가 같을 경우 구별하기 위해 사용
        - `this` 키워드 : 클래스의 프로퍼티 인식
        - 프로퍼티 이름이 중복되지 않을 경우 그냥 호출 가능 
        
## 054. Constructor
   1. `constructor`
        - 생성자
          > 클래스 생성시 자동으로 생성되는 함수          
        - 객체를 초기화 할 수 있음    
        - constructor 키워드 생략 가능
        - 생성자를 정의하지 않으면 매개변수 없는 기본 생성자 자동 생성
   2. `initializer`
        - 초기화
          > 객체의 프로퍼티 값 생
        - 생성자의 매개변수는 init 블록 내부에서 사용
        - 프로퍼티를 선언과 동시에 초기화 안해도 됨
   
## 055. Initializer
   1. init 블록
         - 순서대로 실행 됨
         - 여러개로 나누어 쓸 수 있
 
## 056. PropertyInConstructor
   1. 생성자 프로퍼티
        - 클래스 생성시 매개변수를 바로 초기화
        - 클래스 내용 없는 경우 중괄호 생략 가능
        
## 057. SecondaryConstructor
   1. Constructor
        - `주생성자`: 클래스 이름 옆에오는 생성자(생략 가능)
        - `보조생성자`: 클래스 내부에 오는 생성자, 여러개 올 수 있음
        - this: 클래스에 포함된 또 다른 생성자 호출는 문법
        
## 058. PropertyGetterSetter
   1. `getter`
        - 저장된 값을 읽으려할 때 호출되는 함수
        - 생략해도 디폴트 getter가 있음     
   2. `setter`
        - 값을 저장하려고 할때 호출되는 함수  
        - 생략해도 디폴트 setter가 있음     
   3. `val` 프로퍼티
        - getter만 존재함
        - 초기값이 주어지면 더이상 값을 변경할 수 없음
   
## 059. OperatorOverloading
   1. 연산자 오버로딩
        - 숫자 타입끼리는 연산자 사용 가능
        - 클래스 끼리 연산하려면 오버로딩 필요

## 060. AccessOperator
   1. `접근연산자`('[]')
        - 문자열 다룰 때 사용
        - 객체의 일부 값 출력 가능
        - 객체 값 입력 방법
        ```kotlin
              // 입력방법1
              birthday[0] = "Java"
              // 입력방법2
              birthday.set(0, "Java")
        ```
      
## 061. InvokeOperator
   1. `호출연산자`('()')
        -  : 함수를 호출 할 때 사용하는 연산자
        - invoke : 오버로딩 멤버함수
        - 인수 개수 자유
        - 인수 생략 가능
        
## 062. InOperator 
   1. `in` 연산자
        - 어떤 값이 객체에 포함되어 있는지 조사하는 연산자
        - `in` : 포함하면 true, 포함안하면 false
        - `!in` : 포함안하면 true, 포함하면 false
        - 반환값은 Boolean 형으로 true, false가 출력됨
        - operator fun `contains` 멤버 함수로 오버로딩 가능

## 063. InfixNotation 
   1. 중위표기법
        - 피연산자 연산자 피연산자의 순서로 표현식을 구성하는 방식
        - 매개변수가 하나면 함수호출 중위표기 사용 가능
        - 함수 선언문 앞에 `infix` 붙여야 함
        - `from`멤버함수 : 중위 표기법 호출
        ```kotlin
              val minus = Minus(3, 6) from Minus(1, 1)
              val minus = Minus(3, 6).from(Minus(1, 1)) // 결과동일함
        ```  

## 064. Inheritance
   1. 상속
        - 기존에 존재하는 클래스를 확장해 새로운 클래스 정의하는 기법
        - 기본적으로 상속은 막음
        - 상속을 사용하려면 클래스 앞에 `open` 키워드 붙여야함
        - `슈퍼크래스` : 상속의 대상이 되는 클래스
        - `서브클래스` : 상속하여 확장된 클래스
        - 상속하면 슈퍼클래스의 프로퍼티와 멤버 함수 사용 가능
        - 상속의 깊이는 `제한 없음`
        - 상속은 `하나의 클래스`만 할 수 있음
          
## 065. Upcasting
   1. `캐스팅`(형변환)
        - 특정 타입을 다른 타입으로 변환하는 것
        - 서브클래스의 인스턴스를 슈퍼클래스 타입으로 가리킬 수 있음
        - 상속의 용도
            - 클래스 확장보다는 유사한 객체를 하나의 타입으로 받을 수 있게 하기 위해 사용
            - 단순히 클래스 확장이 목표라면 확장함수나 확장 프로퍼티 이용 추천
       - 슈퍼클래스는 항상 슈퍼클래스 자체나 서브클래스 인스턴스만 가리킴
       - error: Unresolved reference: date
       
## 066. FruitOverriding
   1. `오버라이딩`
        - 슈퍼클래스와 서브클래스의 멤버함수가 동일하면 동작을 덮어쓰는 것
        - 오버라이딩 허용하려면 함수 앞에 `open` 키워드 필요
        - 오버라이딩 사용시 함수 앞에 `override` 키워드 필요
        - `super` 키워드 : 슈퍼클래스 이름을 나타냄
        - `final` 키워드 : 더이상 오버라이딩 할수 없게 됨
            > 오버라이딩 하려고 하면 에러 발생 'func' in 'Fruit' is final and cannot be overridden

## 067. OverridingProperty
   1. 프로퍼티 오버라이딩
        - 프로퍼티 앞에 `open` 키워드 필요
        - 사용시 함수 앞에 `override` 키워드 필요
        - 슈퍼클래스에서 val 선언한 프로퍼티를 var로 오버라이딩 가능
        
## 068. Polymorphism
   1. `다형성`
        - 오버라이딩된 멤버함수 호출 : `실제 가리키는` 객체 멤버 함수 호출
        - third 변수가 First 클래스 타입이지만 Second 함수 호출
         
## 069. ObjectExtends
   1. 클래스 상속하는 객체
        - 클래스 없이 object 표현식으로 상속 가능
        - 표현 : object: 슈퍼클래스 이름(생성자 인수)
        
## 070. Anyclass
   1. `Any` 클래스
        - 모든 코틀린 클래스는 Any클래스가 상속
        - 클래스를 상속하지 않아도 자동으로 Any 클래스 상속
   2. Any 클래스 멤버함수
        - `equals()` : 연산자를 오버로딩하는 함수
        - `hasCode()` : 객체 고유의 해시코드를 반환하는 함수
        - `String()` : 객체 내용을 String 타입으로 변환하는 함수

## 071. NumberFormatException
   1. 예외
        - 프로그램 실행 중 예상치 못하게 발생한 상황
        - 예외 발생시 프로그램은 기본적으로 오류 메시지 보여주고 종료됨
        
## 072. ExceptionHandling
   1. 예외처리
        - 예외 발생시 강제 종료를 막을 수 있음.
        - `try` : 예외 발생 가능성 있는 부분
        - `catch` : 예외가 발생할 경우 대신 실행할 코드
        - `finally` : 예외 발생 여부와 상관없이 무조건 실행되는 블록(생략 가능)
        - 여러 종류의 예외 처리하려면 catch 블록 여러번 사용
        
## 073. ThrowException
   1. 예외 던지기
        - 예외를 고의로 발생시키는 것
        - 예외가 던져지면 자신을 호출한 함수에 예외 처리의 책임을 전가시킴
        - 예외 던지는 방법
        ```kotlin
              throw Exception("0으로 나눌 수 없습니다.")
        ```
        - `throw` 키워드 필수가 아니고 옵션

## 074. NothingType
   1. Nothing 타입
        - 실행 흐름이 도달할 수 없는 구역을 나타내기 위한 특수타입
        - throw Exception() 표현식 Nothing 타입을 갖음
        - 어떠한 타입과도 호환
        - throw를 표현식으로 쓸 수 있기 위한 장치
        
## 075. NullableAndNull
   1. `Nullable`
        - null 값을 지정할 수 있는 변수
   2. `null`
        - 참조 변수가 어떠한 객체가 없음을 나타냄
        - Byte, Short, Int, Long, Float, Double, Char, Boolean 타입 뒤에 ?를 붙이면 그 변수는 참조변수가 됨
        - 코틀린은 Nullabe타입 아니면 null을 지정 못함

## 076. SafeCallOperator
   1. 안전한 호출 연산자(?)
        - Nullable한 참조 변수의 프로퍼티와 멤버 함수에 접근하려면 ?연산자 사용
        - null 값에 안전한 연산자
                
## 077. NotNull
   1. Not-null 단정 연산자(!!)
        - Nullable 타입을 Not-null타입으로 강제 캐스팅
        - null이 있으면 KotlinNullPointerException 예외 발생
        
## 078. ElvisOperator
   1. 엘비스 연산자 (?:)
        - 왼쪽의 피연산자가
            - null이 아니면 그 값을 그대로 사용
            - null이면 우측의 피연산자로 대체됨
        
## 079. SmartCasting
   1. 스마트 캐스팅
        - 특정 조건을 만족하는 경우, 컴파일러는 변수 타입을 다른 타입으로 자동 캐스팅 함 

## 080. isOperator
   1. is 연산자
        - 참조 변수가 실제로 가리키는 객체의 타입 알수 있음
        - java의 instanceof와 비슷
        
## 081. AsOperatorDownCasting
   1. 다운캐스팅
        - 업캐스팅과 반대로 슈퍼클래스 타입을 서브 클래스 타입으로 받는 것
        - as 연산자 : 왼쪽 피연산자를 오른쪽 피연산자로 캐스팅
        - 캐스팅 실패시 `ClassCastException` 발생
        - 예외를 막으려면 as? 연산자 대신 사용
        
## 082. AccessModifier
   1. 접근지정자(가시성지정자) 
        - 코틀린에서 선언 가능한 요소 중 일부 요소에는 접근 권한이라는 것 지정할수 있음
   2. 종류
        - public: 모든 곳에서 접근 가능(생략시 기본 public)
        - internal: 같은 모듈안에서 접근 
        - protected: 클래스 내부와 서브클래스 안에서만 접근 가능
        - private: 프로퍼티와 멤버함수일 경우 해당 클래스 안에서만 접근 가능
             
## 083. Private
   1. private 접근 지정자
        - 같은 파일 내에서만 접근 가능
        - 외부에서 접근시 오류 발생
        - set을 private 지정시 외부에서 값 지정 못함
        
## 084. Protected
   1. protecd 접근 지정자
        - 클래스 내부에서 사용 가능
        - 슈퍼클래스를 상속하면 서브클래스에서 접근 가능
        - 외부에선 접근 불가
        
## 085. Overriding
   1. 오버라이딩
        - protected인 프로퍼티나 멤버 함수의 접근 지정자 public 변경 가능
        - 오버라이딩 가능하게 open 키워드 필요
        - private 프로퍼티, 멤버함수 
            - 접근 불가하므로 오버라이딩 못함
            - open 키워드 지정 못함
            
## 086. StringExtensionFunction
   1. 확장함수
        - 클래스 밖에서 멤버 함수를 추가하는 것
        - 상속없이 클래스 외부에서 멤버 함수 추가 가능
        - 함수이름 앞에 함수를 주입할 클래스를 붙여주면 됨
        - 이미 존재하는 멤버함수와 동일할 경우
            - 오류는 나지 않지만 확장함수가 가려짐
            - 함수 호출시 멤버 함수만 항상 호출 됨 
            
## 087. StringExtensionProperty
   1. 확장프로퍼티
        - 확장함수와 비슷함
        - 함수이름 앞에 함수를 주입할 클래스 : 리시버 타입
        - 함수와 다른점은 프로퍼티이기에 소괄호를 쓰지 않음
        
## 088. ObjectDeclaration
   1. 객체 선언
        - 클래스 선언 형태와 비슷
        - 공유할 수 있는 하나뿐인 객체 필요할 때가 있음
        - 객체는 open 키워드를 붙일 수 없음
   2. 객체 접근 방법
   ```kotlin
        Person.name = "Singleton"
        var person:Person = Person
        println(person.name)
   ```
        
## 089. CompanionObject
   1. `동반자 객체`
        - 클래스 안에 포함되는 `이름 없는 객체`
        - 모든 인스턴스가 공유하는 객체 만들고 싶을때 사용
        - static가 코틀린엔 없지만 같은 효과내려면 동반자 객체 사용
        
## 090. InlineHelloWorld
   1. `inline` 함수
        - 함수 호출문이 함수 속에 들어 있는 문장으로 대체 됨
        - 실행 흐름 점프하지 않고 함수 호출문을 몸체로 대체 함
        - 재귀호출 불가능, 함수 몸체코드가 무한히 늘어날 수 있음

## 091. FooConst
   1. `const`
        - inline함수와 비슷하게 val 변수 앞에 붙이면 접근하는 코드를 변수에 저장된 값으로 대체 시킴
        - `전역변수`, `오브젝트의 프로퍼티` 사용 가능
        - 프로그램 어디서나 접근 가능한 변수
        - 리터럴로 이루어진 표현식만 저장 가능
        
## 092. LateInit
   1. `LateInit`
        - 클래스 안에서 바로 초기화 하지 않음
        - lateinit var 프로퍼티만 붙일 수 있음
        - 나중엔 값 채워줘야 예외 발생하지 않음
        - 값 지정안하고 접근시 
            > UninitializedPropertyAccessException 에러 발생
   2. 초기화
        - 클래스의 프로퍼티는 선언과 동시에 초기화
        - init 블록안에 반드시 초기화

## 093. Nullable
   1. `Nullable`
        - 참조변수에 null이 지정되어 있어도 확장 함수 응용시 함수 호출이 가능하게 함
        - 리시버 타입 `?`(가 Nullable 리시버)
        
## 094. CompanionExtend
   1. `동반자 객체 확장 함수`
        - 동반자 객체는 클래스 이름만 접근 가능
        - 확장함수 선언시 객체 아닌 클래스에 자체 멤버 함수추가되므로 Companion 식별자 필요

## 095. InheritExtension
   1. 확장함수 상속
        - 확장함수 리시버 타입이 상속 관계일 경우 부모 함수 호출
        - 멤버함수는 참조변수가 실제로 가리키는 객체 타입을 따름
        - 참조 변수 타입을 그대로 따름
        
## 096. AbstractClass
   1. `추상클래스`        
        - `abstract` 키워드 사용
        - 클래스 선언 맨 앞에 키워드 붙임
        - 자체로 open 키워드 붙어 있음
        - 일부 멤버의 내용이 비어있는 불완전한 클래스 객체 생성 못함
        - 추상 프로퍼티 : 추상 멤버 함수처럼 프로퍼티 선언문 맨 앞에 abstract키워드 필요
        - 추상클래스를 상속하는 일반클래스는 반드시 멤버함수 오버라이딩 필요
        
## 097. PrintInterface
   1. `인터페이스`
        - `interface` 키워드 사용
        - 클래스에 어떤 멤버 함수와 프로퍼티가 반드시 존재한다는 것을 보장하는 장치
        - 멤버함수, 추상 멤버 함수, 추상 프로퍼티 가질 수 있음
        - 일반 프로퍼티와 생성자는 못 갖음
        - 코틀린의 인터페이스의 멤버함수는 기본구현 가질 수 있음
        - 멤버함수는 내용이 비어있으면 자동으로 abstract가 붙음
        - 생성자가 없으므로 상속할때 이름 옆에 ()를 쓰지 않음
        
## 098. DiamondProblem
   1. `다이아몬드 문제`
        - 인터페이스 `여러개 상속`할 떄 문제 발생할 수 있음
        - 상속을 여러개 받을때 어떤걸 호출할지 애매
        - 코틀린은 어떤걸 호출할지 정할 수 있음
        
## 099. NestedClass
   1. `중첩 클래스`
        - 클래스 안에 또 다른 클래스 선언 가능
        - 타입은 바깥 클래스.중첩 클래스 형태로 만들어짐
        - 생성자 호출시 중첩된 클래스가 출력
        - Outer 클래스와 Nested 클래스는 별개의 클래스(멤버함수 공유 안함)
        
## 100. InnerClass
   1. `내부 클래스`
        - 인스턴스가 바깥 클래스에 완전히 소속됨
        - OuterClass.Inner로 인스턴스에 접근
        - this@OuterClass 키워드 : 바깥 클래스 인스턴스에 접근

## 101. DataClass
   1. `데이터 클래스`
        - `data` 키워드
        - 클래스 앞에 data를 붙임
        - 데이터에 특화된 클래스
        - 적어도 하나의 프로퍼티를 가져야 함
        - 생성자 매개변수에 var, val 같이 써야 함
        - equals, hashCode, toString 멤버함수가 자동으로 오버라이딩 됨
        - abstract, open, sealed, inner 키워드 사용 못함
        
## 102. DestructuringObject
   1. `객체 분해하기`
        - 사용되지 않는 변수는 언더스코어(_)를 쓰면 무시 가능
        - 데이터클래스의 필요한 부분만 추출 가능

## 103. FunctionLiteralLambda
   1. `함수리터럴`
        - 함수를 나타내는 리터럴
   2. `함수타입`
        - 함수를 저장할 수 있는 타입
   3. `람다식`
        - { 매개변수 -> 반환값 }형태

## 104. AnonymousFunction
   1. `익명함수`
        - 함수리터럴을 표현하는 또 다른 방식
        - inline 키워드 사용 못함
        - return으로 반환 값 지정 가능
        - 람다식보다 버그 일으킬 확률이 적음

## 105. ItIdentifier
   1. `it 식별자`
        - 람다식에서 매개변수 하나일 경우 생략 가능
        - 매개변수를 생략하면 it이 매개변수를 대체 함
        
## 106. FunctionReference
   1. `함수참조`
        - 함수 타입의 변수는 이미 선언된 함수나 객체 멤버 함수를 가리킴
        - `Object`, `class`, `fun` 함수 참조
        
## 107. HigherOrderFunction
   1. `고차함수`
        - 인수로 함수를 받거나 함수를 반환하는 함수
        - 함수 호출시 소괄호 써줘야하지만 함수 타입은 소괄호 생략 가능
        
## 108. SituationRememberClosure
   1. `클로저`
        - 함수가 만들어 질때 주변 상을 기억하는 함수

## 109. FunctionLiteralWithReceiver
   1. `리시버 적용된 함수 리터럴`
        - 익명함수 형태로 함수 리터럴 작성 가능
        - `this` 키워드 사용 가능

## 110. GenericDate
   1. `제네릭`
        - 인수를 전달하듯이 함수에 타입을 전달할 수 있음
        - <식별자> 형태로 함수에 타입 적용

## 111. GenericTwoSquared
   1. `제네릭 여러 타입 선언`
        - 타입 매개변수를 여러개 선언 가능
        - <타입1, 타입2> 형식으로 선언
        
## 112. ReifiedTypeParameter
   1. `구체화된 타입 매개변수`
        - 타입 매개변수는 is 연산자의 피연산자로 사용 못함
        - is 연산자 사용하려면 타입 매개변수 앞에 `reified` 선언 필요
        - reified를 붙이려면 `inline`으로 선언해야 함
        
## 113. GenericToClassAndInterface
   1. 클래스와 인터페이스에서 제네릭 사용
        - 클래스나 인터페이스에 타입 인수로 받으려면 선언시 이름 옆에 <식별자> 필요
        - 모든 타입은 Any 클래스를 상속하므로 toString 멤버함수 가지고 있
        
## 114. InheritFromGeneric
   1. 상속을 적용한 제네릭 클래스
        - 제네릭 클래스, 인터페이스는 상속할 때 타입 인수 전달 필요

## 115. GenericSpecificType
   1. 특정 타입을 상속 구현
        - 타입 매개변수로 특정타입을 상속 구현
        - 구현한 인터페이스의 멤버함수 호출 가능
        
## 116. GenericInOut
   1. 타입 업캐스팅
        - Int -> Any
        - `out` 키워드 필요 
   2. 타입 다운캐스팅 
        - Any -> Int
        - `in` 키워드 필요
   3. 모든 타입 캐스팅
        - `*` 키워드 사용
        - 어떤 타입이든 대입 가능
        
## 117. RangeExpression
   1. 연산자 `범위 표현식`
        - `..` : 범위 연산자
   2. 정수 범위
        - 1..10
        - 1.rangeTo(10)
   3. 문자 범위
        - A..Z
        - A.ragneTo('Z')
        
## 118. OneToThreeIterator
   1. `반복자`
        - 특정 구간 속에 있는 원소를 하나씩 반복적으로 꺼내기 위한 인터페이스
        - Iterator: 코틀린의 기본적인 인터페이스
        - 함수
            - next() : 다음 원소가 있으면 반환 후 출력
            - hasNext() : 다음 원소가 있는지 true, falsef로 반환 함
            
## 119. OneToTenForIterator
   1. `for` 
        - 반복문
        - 타입 생략 가능
        - 형태
            for (변수 이름: 타입, in 표현식)

## 120. TenToFortyArray
   1. 배열
        - `array`
            - 변수 선언시 타입 적어줘야 함ㅎㅎ
            - arrayOf()에는 <Int> 생략 가능
            - 괄호 안에 () 값 입력
        - 프로퍼티
            - `size`: 배열의 원소개수
            - `get`: [] 연산자로 접근
            - `iterator()`: 배열을 for문 쓸수 있게 해줌
            
## 121. ArrayToVararg
   1. 배열 가변 인수 출력
        - `가변인수 출력 함수`
            - `vararg`: 가변인자 받을 때 사용하는 키워드 
            - 배열 앞 * 사용시 가변인수 활용 가능

## 122. EnumClass
   1. `열거 클래스`
        - 정해진 집합 내의 값을 표현하는 용도
        - 선언문 앞에 `enum` 키워드 사용
        - `열거 상수` : 열거 클래스에 들어가는 식별자
        
## 123. EnumClassMember
   1. 열거클래스 멤버함수 선언
        - 일반 클래스처럼 매개변수에 프로퍼티 선언
        - 마지막 열거 상수에는 끝에 세미콜론(;)을 붙여야 함
        - 열거 클래스의 프로퍼티, 멤버함수
            - 열거 상수 나열문보다 뒤에 와야 함
        
## 124. EnumClassFunctionProperty
   1. 열거클래스 활용
        - 기본 함수와 프로퍼티
            - name: String
            - ordinal: Int
            - valueOf(value: String)
            - values()

## 125. SealedClass
   1. `sealed` 클래스
        - 자신의 중첩 클래스에만 상속을 허용하는 클래스
        - 1.1 버전 이후 sealed 클래스와 같은 파일에 있는 경우도 상속 가능

## 126. DelegatedProperty
   1. 위임된 프로퍼티
        - `Getter/Setter` 구현을 다른 객체에 맡길수 있음
        - `by` 뒤에 클래스로 위임 클래스에서 Getter/Setter 구현
        
## 127. ClassDelegation
   1. 클래스 위임
        - 인터페이스 구현을 다른 클래스에 맡길 수 있음
        - 인터페이스 구현하면서 뒤에 `by` 객체 지정해 인터페이스 구현을 위임


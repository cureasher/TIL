# 코딩테스트 정리
## 1. 문자열 조작
### 1) [유효한 팰린드롬](../code/StringControll/ValidPalindrome.kt)
- 접근방법
    - 대소문자 구분안하므로 문자열 소문자나 대문자로 변환
    - 영문자와 숫자만을 대상으로 확인
    - 구현시 자바와의 차이점
        - 자바는 replaceAll을 써야하지만 kotlin은 `toRegex()`를 쓰고 `replace`로 문자열 처리함.
### 2) [문자열 뒤집기](../code/StringControll/ReverseString.kt)
- 접근방법
    - 문자 배열 입력 받기
    - 리턴 없이 내부 리스트 조작
    - `reversed()`함수로 문자열 뒤집음
### 3) [가장 흔한 단어](../code/StringControll/MostCommonWord.kt)
- 접근방법
    - 문자열을 소문자로 변환
    - 정규식으로 문자 외에는 " "으로 치환
        - ([^\\w])단어 문자가 아닌 모든 문자
    - " "으로 쪼갬(split)
    - banned 아닌 것만 찾아라
    - 값이 제일 많은것을 출력
### 4) [로그 파일 재정렬](../code/StringControll/ReorderLogFiles.kt)
- 접근방법
    - 첫번째 공백으로 로그 식별자 구분(map 함수로 필요한 로그 분리)
    - partition함수를 통해 문자로그와 숫자로그 구분
    - sortedWith함수에서 compareBy를 통해 문자로그 비교 후 식별자 비교
    - 정렬된 문자로그와 숫자로그를 합친 값 출력
### 5) [그룹 애너그램](../code/StringControll/GroupAnagrams.kt)
- 접근방법
    - groupBy 함수로 문자열의 Key, Value로 그룹을 묶음
    - toCharArray()를 사용해 문자 배열 만듦
    - 문자 배열을 정렬해서 결과값을 리스트로 출력
### 6) [가장 긴 팰린드롬 부분 문자열](../code/StringControll/LongestPalindrome.kt)
- 접근방법
    - words.indices == 0 until words.length
    - bb일경우에도 팰린드롬이므로 아닌 경우 break로 나가게 조건문 설정
    - slice함수 : 슬라이싱으로 시작부터 끝까지 문자열 자르기
    - first는 1개씩 앞으로가고 last는 뒤로가는 형태로 확장
## 2. 배열
### 1) [두수의 합](../code/Array/TwoSum.kt)
- 접근방법
    - 정수형 배열 입력
    - 인덱스 있는 배열 선언 withIndex()함수 사용
    - 타겟에서 첫번째 값을 뺀 값을 타겟 체크 변수에 저장
    - containsKey()함수로 map에 타겟 체크 변수의 값이 있는지 확인
    - 타겟 체크 값이 있으면 출력
### 2) [빗물 트래핑](../code/Array/TrappingRainWater.kt)
- 접근방법
    - 왼쪽이 오른쪽보다 크면 진행
    - 오른쪽은 리스트의 사이즈의 1뺀 값
    - 투 포인터를 최대로 이동하는 형태
    - 왼쪽 최대값, 오른쪽 최대값 값을 구한다
    - 왼쪽 최대값과 오른쪽 최대간을 비교
    - 오른쪽 최대값이 크면 왼쪽 최대값에서 왼쪽 높이를 뺀다
    - 왼쪽 최대값이 크면 오른쪽 최대값에서 오른쪽 높이를 뺀다.
    - 반복문 나오면 저장된 용량 출력
### 3) [세 수의 합](../code/Array/ThreeSum.kt)
- 접근방법
    - 왼쪽과 오른쪽 투포인터로 확인
    - 3가지 수의 합이 0이면 
    - while문으로 왼쪽값과 오른쪽값이 작은 동안 비교하며 합을 비교
    - when문으로 sum이 0일때와 0보다 작을 때, 클때를 분기
### 4) [배열 파티션1](../code/Array/ArrayPairSum.kt)
- 접근방법
    - sorted() 함수로 정렬을 해준다.(sort()함수는 windowed함수 사용 못 함)
    - windowed 함수로 size가 2인 함수로 2개씩 map으로 묶음
    - 나눈 배열에서 Math.min 함수로 최소값을 구하고 sum함수로 합계를 출력
### 5) [자신을 제외한 배열의 곱](../code/Array/ProductExceptSelf.kt)
- 접근방법
    - 입력한 결과값 저장하는 배열(배열 요소의 곱을 저장)
    - 초기에는 배열의 길이 만큼 1로 배열 생성
    - 배열의 길이를 변수로 지정
    - start에는 순서대로 값을 곱함
    - end에는 거꾸로 값을 곱함
    - 배열의 요소를 곱함
    - 배열의 길이에서 인덱스 뺀값을 계속 곱함
    - 배열의 곱이 진행된 배열 결과값 출력
### 6) [주식을 사고팔기 가장 좋은 시점](../code/Array/MaxProfit.kt)
- 접근방법
    - 저점과 현재 값과의 차이를 계산
    - 최소값을 변수에 저장
    - 최소값과 현재 가격을 비교하며 min 함수로 최소값 교체
    - max함수로 profit체크와 현재가격에서 최소값을 뺀값 비교를 통해 최대값 저장
    - 최대 이익 출력
## 3. 연결리스트
### 1) [팰린드롬 연결리스트](../code/LinkedList/IsPalindrome.kt)
- 접근방법
    - 맵을 생성
    - head 노드 생성
    - 투포인터 접근 비교
    - 팰린드롬 확인시 같지 않으면 false 출력
    - 팰린드롬일 경우 true 출력
### 2) [두정렬 리스트의 병합](../code/LinkedList/MergeTwoList.kt)
- 접근방법
    - 연결리스트 2개를 생성
    - 첫번째 연결리스트와 두번째 연결리스트의 값을 비교
    - 첫번째 리스트가 크면 첫번째 연결리스트 값 리턴 아니면 두번째 연결리스트 값 리턴
    - 코틀린 파라미터 참조시 주의사항
        - 코틀린 파라미터는 불변이기에 함수안에서 var로 변수를 담아줘야함
    - 값이 잘들어갔는지 확인하는 함수 생성후 출력형태 확인
### 3) [역순 연결 리스트](../code/LinkedList/ReverseLinkedList.kt)
- 접근방법
    - 반복 구조로 뒤집기
    - 이전노드, 현재노드 변수 생성
    - 현재노드가 널이 아닐동안 반복만 수행
    - 다음노드 변수 생성후 현재노드의 next 값 넣기
    - 현재, 이전, 다음 노드간 값 교환
    - 교환된 값 출력
### 4) [두 수의 덧셈](../code/LinkedList/AddTwoNumber.kt)
- 접근방법
    - 전가산기 유사한 형태로 구현
    - 첫번째 리스트, 두번째 리스트, 캐리 확인
    - 재귀로 연결리스트의 next 값 더하기, 올림이 있으면 올림도 계산
    - 엘비스 연산자(:? 널일 경우 0으로 값 대체)
    - 연결리스트 더한 값 출력
### 5) [페어의 노드 스왑](../code/LinkedList/SwapPairs.kt)
- 접근방법
    - 반복구조로 스왑 처리
    - 현재노드, 다음노드 변수 생성
    - 현재노드는 head 값 입력
    - 다음노드는 head의 다음노드 값 입력
    - 다음노드가 null이 아닐동안 반복
    - 임시노드, 현재노드, 다음노드간 교환
    - 다음 비교를 위해 현재노드와 다음노드를 한칸 앞 이동, 두칸 앞으로 이동
    - 스왑된 연결리스트 출력
### 6) [홀짝 연결 리스트](../code/LinkedList/OddEvenList.kt)
- 접근방법
    - 반복구조로 홀짝 처리
    - 홀수변수, 짝수 변수, 짝수헤드변수 생성후 값 저장
    - 짝수 인덱스와 홀수 인덱스별 연결리스트에 저장
    - 홀수 연결리스트 나오고 짝수 연결리스트 연결한 값 출력
### 7) [역순 연결 리스트2](../code/LinkedList/ReverseBetween.kt)
- 접근방법
    - 루트노드에 -1로 연결리스트 생성
    - 루트노드의 next에 연결리스트 값을 넣음
    - repeat함수로 횟수만큼 반복
    - 연결리스트의 시작값부터 끝값까지 템포를 통해 값 변경
    - 연결리스트 결과 출력
## 4.스택
### 1) [유효한 괄호](../code/stack/ValidParentheses.kt)
- 접근방법
    - 자바의 기본 라이브러리르 Stack 사용
    - peek() : 스택에 값이 있는지 확인
    - pop() : 스택에서 값을 빼냄
    - push() : 스택에 값을 넣음
    - isEmpty() : 값이 있는지 확인하여 있는경우 true, 없으면 false 리턴
    - 괄호의 길이가 짝수인지 확인(홀수이면 짝이 안맞기 때문)
    - 괄호를 reversed함수를 통해 뒤에서부터 괄호를 스택에 집어 넣음
    - when문을 통해 여는 괄호('(','[,'{')가 있는지 확인
    - if문을 통해 여는 괄호가 있을 때마다 스택에서 pop으로 값을 빼냄
    - stack.isEmpty()를 통해 스택에 값이 남아있는지 확인하고 결과 출력
### 2) [중복 문자 제거](../code/stack/RemoveDuplicateLetters.kt)
- 접근방법
    - HashSet으로 중복된 문자 확인
    - Stack 라이브러리 사용
    - 가능한 결과가 사전식으로 정렬
    - 카운트, 스택 사용
    - 알파벳 갯수 만큼 정수형 카운트 배열 만듦
    - 문자열을 반복하면서 중복된 값 카운트 증가
    - check를 통해 값이 포함되어있으면 
    - 스택이 비어있지 않고 stack의 현재값이 문자보다 크고 정수형 배열
    - 중복 확인하면서 스택의 값 제거
    - 스택에 들어온 리스트를 joinToString으로 문자열로 결과값 출력
### 3) [일일 온도](../code/stack/DailyTemporatures.kt)
- 접근방법
    - ArrayDeque를 이용해 스택 만듦
    - forEachIndexed를 사용해 인덱스별 온도를 반복수행
    - 인덱스마다 온도리스트에 값을 기본적으로 0을 넣음
    - while문을 통해 스택이 비어있지 않고 현재 온도와 다음 온도보다 값 비교후 온도리스트 값 교체
    - 더높은 온도가 나오지 않으면 스택에 쌓이지 않음
    - 쌓인 값들을 온도리스트에 값 등록
    - 현재 온도가 스택 값보다 높으면 정답처리
    - 처리된 인덱스는 스택에서 팝으로 제거
    - 온도리스트 결과 출력
## 5. 큐
### 1) [큐를 이용한 스택 구현](../code/queue/ImplementStackUsingQueues.kt)
- 접근방법
    - ArrayDeque를 통해 큐기능만 사용해 스택 구현
    - push는 queue의 사이즈 변수로 생성 및 값 등록
    - pop은 큐에서 값을 꺼내고 제거
    - top은 큐의 맨위의값을 꺼내서 보여줌
    - empty는 queue가 비어 있는지 상태 반환
### 2) [스택을 이용한 큐 구현](../code/queue/ImplementQueueUsingStacks.kt)
- 접근방법
    - ArrayDeque를 통해 스택기능만 사용해 큐 구현
    - push은 add()함수로 구현
    - pop은 RemoveFirst() 첫번째 값 제거
    - peek은 first()함수로 첫번째 값 가져옴
    - empty는 isEmpty()로 비어있는 상태값 리턴
    - peek은 조회하고 pop은 제거한 값을 보여줌
### 3) [원형 큐 디자인](../code/queue/MyCircularQueue.kt)
- 접근방법
    - 배열을 이용한 풀이
    - FIFO 구조를 지님(큐와 동일)
    - 마지막 위치가 시작위치와 연결되어 있음
    - 동작원리는 투포인터와 비슷함
    - 마지막 위치와 시작위치를 연결하는 원형구조
    - front, rear의 초기값은 0으로 설정
    - 정수형 배열을 원형큐의 길이만큼 생성
    - enQueue는 큐가 꽉차있으면 false 반환, front는 1을 더해주고 큐사이즈 1증가
    - deQueue는 큐가 비어있으면 false 반환, rear에 1을 더해주고 큐사이즈 1감소
    - Front와 Rear는 비어있으면 -1 반환 아닌 경우 큐에 값을 넣음
    - isEmty와 isFull은 비어있거나 가득차있는지 확인하는 함수
## 6. 데크
### 1) [원형 데크 디자인](../code/deque/MyCircularDeque.kt)
- 접근방법
    - 이중 연결리스트를 위한 풀이
    - insertFront()와 insertLast()는 데크 앞쪽과 끝쪽에 아이템 추가하고 성공하면 true 반환
    - deleteFront()와 deleteLast()는 데크의 처음과 마지막의 아이템을 삭제하고 성공한 경우 true 반환
    - getFront()와 getRear()는 데크의 첫번째와 마지막 아이템을 가져오는 함수 비어있는 경우 -1 리턴
    - isEmpty(), isFull() : 데크가 비어있거나 가득차있는지 여부를 확인하는 함수
    - 왼쪽, 오른쪽 인덱스 역할하는 head, tail 정의
    - 데크의 최대길이 정보 size로 설정
### 2) [k개 정렬 리스트 병합](../code/deque/MergeKSortedLists.kt)
- 접근방법
    - 우선순위큐를 이용한 리스트 병합
    - 3개의 연결리스트를 입력받고 최소힙에 집어 넣음
    - 우선순위큐는 꺼낼때 가장 작은 노드부터 차례대로 나옴(최소힙) 나온값은 결과노드에 저장
    - head는 힙이 비어있지 않으면 최소힙에서 꺼낸값을 리스트 노드에 넣음
    - 최소힙에 값이 쌓이면 순서대로 힙이 빌때까지 값을 출력
## 7. 해시 테이블
### 1) [해시맵 디자인](../code/hashtable/DesginHashmap.kt)
- 접근방법
    - put 키값을 해시맵에 삽입(이미 존재하는 경우 업데이트)
    - get 키에 해당하는 값 조회하고 키가 없는 경우 -1반환
    - remove 키에 해당하는 키값을 해시맵에서 삭제
    - arrayOfNulls 초기값이 null인 배열
    - clacHash hashsize를 나눈 몫으로 key 확인하는 함수
### 2) [보석과 돌](../code/hashtable/JewelsAndStones.kt)
- 접근방법
    - contains로 보석의 개수를 카운트함
    - 돌을 필터해서 보석을 포함하고 있으면 값을 가져옴
    - 카운트 결과를 반환
### 3) [중복 문자 없는 가장 긴 부분 문자열](../code/hashtable/LengthOfLongestSubstring.kt)
- 접근방법
    - 입력받은 문자열이 null이거나 0이면 0 반환
    - 사용된 문자열과 최대길이 변수 생성
    - 한번 사용된 문자가 포함되어 있으면 문자열 끝에 붙임
    - 중복된 경우 숫자 최대길이 더해지지 않음
    - 문자열 최대길이와 사용된 문자열 비교후 큰 값으로 교환
    - 문자열 최대길이 결과값 반환
### 4) [상위 K 빈도 요소](../code/hashtable/TopKFrequentElements.kt)
- 접근방법
    - groupBy함수로 숫자별 그룹을 지정
    - 그룹 된 것을 toList()함수로 다시 리스트로 변환
    - 리스트의 두번째 요소의 사이즈를 확인해 내림차순 정렬
    - take함수로 최소 개수만큼 리스트를 가져옴
    - 가져온 리스트를 map()함수를 통해 리스트의 첫번째 요소만 가져와 출력
## 8. 그래프
### 1) [섬의 개수](../code/graph/NumberOfIslands.kt)
- 접근방법
    - 2차원 배열 입력
    - 0과 1만 사용
    - 1인 경우에만 dfs 재귀로 동서남북 호출
    - dfs는 x, y는 0보다 크고, x가 그리드사이즈보다 작으면, y가 그리드 사이즈보다 작고 그리드의 값이 1인 경우
    - 재귀로 돌면서 돌았던 곳은 0으로 변경
    - 섬의 개수 결과값 반환

